---
title: Unidad 3
unitId: unit3
---

import { Aside } from '@astrojs/starlight/components';

## Introducci√≥n üìú

En esta unidad vas a seguir explorando la integraci√≥n entre micro:bit y p5.js,
al tiempo que profundizar√°s en la t√©cnica de programaci√≥n con m√°quinas de estado. 
Volver√°s a practicar dicha t√©cnica con el micro:bit, pero tambi√©n en p5.js.

Te preguntar√°s ¬øPor qu√© tanta insistencia del profe con esta t√©cnica? Y la raz√≥n 
es que ella te permitir√° lograr en tus aplicaciones escalabilidad, en t√©rminos de 
concurrencia, es decir, permitir√° que una aplicaci√≥n tenga m√∫ltiples TAREAS 
haciendo al mismo tiempo varias cosas.


## R√∫brica de evaluaci√≥n de la unidad üìù

:::note[Transparencia]
Esta r√∫brica se socializa antes de la sustentaci√≥n. La sustentaci√≥n se 
basa en lo presentado en la aplicaci√≥n y lo documentado en la bit√°cora. 
:::

### Requisito de salida (condici√≥n necesaria)

:::caution[Para poder cerrar la evaluaci√≥n y registrar la nota]
La **bit√°cora de reflexi√≥n** debe estar diligenciada antes de terminar 
la sesi√≥n final y debe ser ense√±ada al profesor antes de abandonar el aula.
La presentaci√≥n de la bit√°cora de reflexi√≥n es un requisito indispensable 
para montar la nota final en la plataforma acad√©mica. Si no se cumple este 
requisito, la nota final de la unidad ser√° 0.0.
:::

---

### R√∫brica anal√≠tica

:::tip[Evidencias evaluadas]

1) Funcionamiento de la aplicaci√≥n + documentaci√≥n en bit√°cora.
2) Sustentaci√≥n a partir de la app y la bit√°cora de aplicaci√≥n.

:::

| Criterio (peso) | Cumple plenamente (5.0) | Se cumple medianamente (4.0)| Problemas importantes (3.0)| Falta comprensi√≥n b√°sica (2.0) | No hay evidencia (0.0)
|---|---|---|---|---|---|
| **1. Aplicaci√≥n + bit√°cora (40%)** | La app se ejecuta sin fallos en el entorno acordado. Evidencia completa y verificable en bit√°cora. Todo consistente con lo mostrado en la demo. | La app funciona y cumple lo esencial. La bit√°cora permite verificar, pero hay **1‚Äì2 vac√≠os menores**| La app funciona parcialmente o depende de condiciones no declaradas. Bit√°cora con **vac√≠os importantes** o incompleta. | La app no corre o no demuestra lo requerido. La bit√°cora no permite verificaci√≥n de la app.| No se entregaron evidencias o no se puede acceder a ellas |
|Evaluaci√≥n||||||
| **2. Sustentaci√≥n (60%)** | Responde a las preguntas con precisi√≥n, conectando: **(a) lo que se ve**, **(b) c√≥mo est√° hecho**, y **(c) por qu√©**. Usa su bit√°cora para justificar decisiones. Reconoce l√≠mites/errores y propone c√≥mo probar/mejorar. | Respuestas correctas pero con **imprecisiones menores** o justificaci√≥n superficial. Usa parcialmente la bit√°cora para sustentar. | Responde solo ‚Äúqu√© hizo‚Äù pero le cuesta explicar ‚Äúc√≥mo‚Äù o ‚Äúpor qu√©‚Äù. Necesita gu√≠a para conectar con su propia evidencia/bit√°cora. | No logra responder de forma coherente o responde sin relaci√≥n con lo presentado/documentado. Evidencia falta de comprensi√≥n b√°sica del trabajo entregado. | No se entregaron evidencias o no se puede acceder a ellas |
|Evaluaci√≥n||||||
---

:::tip[C√°lculo de la nota]

$$
Nota = C_1*0.4  + C_2*0.6
$$

:::

---

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

Vas a seguir practicando la t√©cnica de programaci√≥n con 
m√°quinas de estado y a transferirla a p5.js.

### Actividad 01

Regresemos a la actividad del sem√°foro de la unidad anterior. Te 
pedir√© que hagas las siguientes modificaciones:

1. Si el bot√≥n A se presiona el sem√°foro debe cambiar a modo "peatonal". 
En este modo el sem√°foro se pone en rojo, pero antes debe pasar por amarillo 
para darle tiempo a los autos a detenerse.

2. Si el bot√≥n B se presiona el sem√°foro pasa a modo nocturno. En este 
modo el sem√°foro parpadea en amarillo. Si el bot√≥n A se presiona en este modo, 
el sem√°foro vuelve a modo normal. 

:::caution[üì§ Bit√°cora]
Recuerda documentar en tu bit√°cora de reflexi√≥n el proceso que seguiste para
implementar estas modificaciones. Es importante que registres los pasos que diste,
los errores que tuviste, c√≥mo los solucionaste, y lo que aprendiste con esta actividad.
No olvides dejar el c√≥digo final que implementaste en tu bit√°cora.
:::

### Actividad 02

Vas a modificar el c√≥digo del temporizador de la unidad anterior as√≠:

1. Si est√° corriendo el temporizador, al presionar el bot√≥n A se debe pausar el conteo.
Si se vuelve a presionar el bot√≥n A, el conteo se reanuda en donde se hab√≠a pausado.

2. Si el temporizador est√° corriendo, si se presiona una secuencia de botones A-B-A, 
el temporizador debo volver a modo de configuraci√≥n. 

<details>
<summary>Te dejo el proyecto base para modificar si no tienes tu propia versi√≥n</summary>
main.py:

```py
from microbit import *
from fsm import FSMTask, ENTRY, EXIT
from utils import FILL
import utime
import music

class Temporizador(FSMTask):
    def __init__(self):
        super().__init__()
        self.event_queue = []
        self.timers = []
        self.counter = 20
        self.myTimer = self.add_timer("Timeout",1000)
        self.estado_actual = None
        self.transition_to(self.estado_config)


    def estado_config(self, ev):
        if ev == ENTRY:
            self.counter = 20
            display.show(FILL[self.counter])
            self.myTimer.start()
        if ev == "A":
            if self.counter > 15:
                self.counter -= 1
            display.show(FILL[self.counter])            
        if ev == "B":
            if self.counter < 25:
                self.counter += 1
            display.show(FILL[self.counter]) 
        if ev == "S":
            self.transition_to(self.estado_armed)

    def estado_armed(self, ev):
        if ev == ENTRY:
            self.myTimer.start()
        if ev == "Timeout":
            if self.counter > 0:
                self.counter -= 1
                display.show(FILL[self.counter])
                if self.counter == 0:
                    self.transition_to(self.estado_timeout)    
                else:
                    self.myTimer.start()
   
    def estado_timeout(self, ev):
        if ev == ENTRY:
            display.show(Image.SKULL)
            music.play(music.FUNERAL)
        if ev == "A":
            music.stop()
            self.transition_to(self.estado_config)
            
temporizador = Temporizador()

while True:
    
    if button_a.was_pressed(): 
        temporizador.post_event("A")
    if button_b.was_pressed():
        temporizador.post_event("B")
    if accelerometer.was_gesture("shake"):
        temporizador.post_event("S")
    
    temporizador.update()
    utime.sleep_ms(20)
```

fsm.py:

```py
import utime

ENTRY = "ENTRY"
EXIT  = "EXIT"

class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration
        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active and utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
            self.active = False
            self.owner.post_event(self.event)


class FSMTask:
    def __init__(self):
        self._q = []
        self._timers = []
        self._state = None

    def post_event(self, ev):
        self._q.append(ev)

    def add_timer(self, event, duration):
        t = Timer(self, event, duration)
        self._timers.append(t)
        return t

    def transition_to(self, new_state):
        if self._state:
            self._state(EXIT)
        self._state = new_state
        self._state(ENTRY)

    def update(self):
        for t in self._timers:
            t.update()
        while self._q:
            ev = self._q.pop(0)
            if self._state:
                self._state(ev)
```

utils.py:

```py
from microbit import Image

def make_fill_images(on='9', off='0'):
    imgs = []
    for n in range(26): 
        rows = []
        k = 0
        for y in range(5):
            row = []
            for x in range(5):
                row.append(on if k < n else off)
                k += 1
            rows.append(''.join(row))
        imgs.append(Image(':'.join(rows)))
    return imgs

FILL = make_fill_images()
# Para mostrar usas display.show(FILL[n]) donde n ser√°
# un valor de 0 a 25
```

</details>

:::caution[üì§ Bit√°cora]
Recuerda documentar en tu bit√°cora de reflexi√≥n el proceso que seguiste para
implementar estas modificaciones. Es importante que registres los pasos que diste,
los errores que tuviste, c√≥mo los solucionaste, y lo que aprendiste con esta actividad.
No olvides dejar el c√≥digo final que implementaste en tu bit√°cora.
:::

## Seek: Investigaci√≥n üîé

### Actividad 03

Ahora vamos a analizar juntos la implementaci√≥n del temporizador en p5.js usando la 
t√©cnica de m√°quinas de estado. Para esto necesito que abras 
[este](https://github.com/juanferfranco/sf1-2026-10-u3-a3) repositorio de GitHub 
y sigamos juntos las instrucciones.

:::caution[üì§ Bit√°cora]
Usa tu bit√°cora para tomar notas durante el an√°lisis de la implementaci√≥n del temporizador 
en p5.js. Registra tus observaciones, dudas, y cualquier idea que te surja al revisar el c√≥digo. 
Esto te ayudar√° a consolidar tu comprensi√≥n de c√≥mo se implementa la t√©cnica de m√°quinas de estado 
en p5.js y a prepararte para la siguiente actividad de aplicaci√≥n.
:::

## Apply: Aplicaci√≥n üõ†

### Actividad 04

Vas a modificar el c√≥digo anterior adicionando:

1. Si est√° corriendo el temporizador, al presionar la tecla A se debe pausar el conteo.
Si se vuelve a presionar la tecla A, el conteo se reanuda en donde se hab√≠a pausado.
2. Si el temporizador est√° corriendo, si se presiona una secuencia de teclas A-B-A, 
el temporizador debo volver a modo de configuraci√≥n. 
3. Vas a controlar el temporizador que est√° funcionando en p5.js usando el micro:bit, 
adem√°s de las teclas del computador. Recuerda que solo deber√°s usar del micro:bit los 
botones A y B y el aceler√≥metro.

:::caution[üì§ Bit√°cora]
Registra en tu bit√°cora el c√≥digo que implementaste para estas modificaciones tanto para 
la parte de p5.js como para la parte del micro:bit. Documenta tambi√©n el proceso que seguiste, 
los errores que tuviste, c√≥mo los solucionaste, y lo que aprendiste con esta actividad.
:::


## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

### Actividad 05

En este punto ya tienes una aplicaci√≥n de temporizador funcionando en p5.js. Para esta actividad de reflexi√≥n, 
vas a reproducir lo que ya tienes de la actividad 4, es decir, el temporizador en p5.js con las modificaciones 
implementadas y controlado por un micro:bit local. Ahora te pedir√© que te juntes con un compa√±ero o compa√±era y 
que adiciones la posibilidad de controlar el temporizador en p5.js de manera remota usado otro micro:bit. 
Es decir, cada grupo tendr√° dos micro:bits, uno para controlar el temporizador localmente y otro para 
controlarlo de manera remota.

Te pedir√© que NO modifiques la implementaci√≥n de la m√°quina de estados del temporizador en p5.js. Esta deber√° seguir 
recibiendo por serial los mismos comandos que recib√≠a antes, solo que ahora el micro:bit local se comnicar√° con el micro:bit remoto 
y servir√° como puente para enviar los comandos del micro:bit remoto a p5.js.

¬øPor d√≥nde puedes comenzar a investigar para resolver este problema? En el editor de micro:bit ingresa a la secci√≥n Reference 
y luego busca all√≠ la secci√≥n Radio. Encontrar√°s que cada pareja de micro:bits deben definir un radio group 
para poder comunicarse entre s√≠. Este radio group no puede repetirse con el de otras parejas, as√≠ que cada grupo 
deber√° elegir un n√∫mero de radio group diferente.

:::caution[üì§ Bit√°cora]
Registra en tu bit√°cora el c√≥digo de p5.js y el de ambos micro:bits que implementaste para esta actividad. 
Documenta tambi√©n el proceso que seguiste, los errores que tuviste, c√≥mo los solucionaste, y lo que aprendiste con esta actividad.
:::

