---
title: Unidad 3
unitId: unit3
---

import { Aside } from '@astrojs/starlight/components';

## Introducci√≥n üìú

En esta unidad vas a seguir explorando la integraci√≥n entre micro:bit y p5.js,
al tiempo que profundizar√°s en la t√©cnica de programaci√≥n con m√°quinas de estado. 
Volver√°s a practicar dicha t√©cnica con el micro:bit, pero tambi√©n en p5.js.

Te preguntar√°s ¬øPor qu√© tanta insistencia del profe con esta t√©cnica? Y la raz√≥n 
es que ella te permitir√° lograr en tus aplicaciones escalabilidad, en t√©rminos de 
concurrencia, es decir, permitir√° que una aplicaci√≥n tenga m√∫ltiples TAREAS 
haciendo al mismo tiempo varias cosas.


## R√∫brica de evaluaci√≥n de la unidad üìù

:::note[Transparencia]
Esta r√∫brica se socializa antes de la sustentaci√≥n. La sustentaci√≥n se 
basa en lo presentado en la aplicaci√≥n y lo documentado en la bit√°cora. 
:::

### Requisito de salida (condici√≥n necesaria)

:::caution[Para poder cerrar la evaluaci√≥n y registrar la nota]
La **bit√°cora de reflexi√≥n** debe estar diligenciada antes de terminar 
la sesi√≥n final y debe ser ense√±ada al profesor antes de abandonar el aula.
La presentaci√≥n de la bit√°cora de reflexi√≥n es un requisito indispensable 
para montar la nota final en la plataforma acad√©mica. Si no se cumple este 
requisito, la nota final de la unidad ser√° 0.0.
:::

---

### R√∫brica anal√≠tica

:::tip[Evidencias evaluadas]

1) Funcionamiento de la aplicaci√≥n + documentaci√≥n en bit√°cora.
2) Sustentaci√≥n a partir de la app y la bit√°cora de aplicaci√≥n.

:::

| Criterio (peso) | Cumple plenamente (5.0) | Se cumple medianamente (4.0)| Problemas importantes (3.0)| Falta comprensi√≥n b√°sica (2.0) | No hay evidencia (0.0)
|---|---|---|---|---|---|
| **1. Aplicaci√≥n + bit√°cora (40%)** | La app se ejecuta sin fallos en el entorno acordado. Evidencia completa y verificable en bit√°cora. Todo consistente con lo mostrado en la demo. | La app funciona y cumple lo esencial. La bit√°cora permite verificar, pero hay **1‚Äì2 vac√≠os menores**| La app funciona parcialmente o depende de condiciones no declaradas. Bit√°cora con **vac√≠os importantes** o incompleta. | La app no corre o no demuestra lo requerido. La bit√°cora no permite verificaci√≥n de la app.| No se entregaron evidencias o no se puede acceder a ellas |
|Evaluaci√≥n||||||
| **2. Sustentaci√≥n (60%)** | Responde a las preguntas con precisi√≥n, conectando: **(a) lo que se ve**, **(b) c√≥mo est√° hecho**, y **(c) por qu√©**. Usa su bit√°cora para justificar decisiones. Reconoce l√≠mites/errores y propone c√≥mo probar/mejorar. | Respuestas correctas pero con **imprecisiones menores** o justificaci√≥n superficial. Usa parcialmente la bit√°cora para sustentar. | Responde solo ‚Äúqu√© hizo‚Äù pero le cuesta explicar ‚Äúc√≥mo‚Äù o ‚Äúpor qu√©‚Äù. Necesita gu√≠a para conectar con su propia evidencia/bit√°cora. | No logra responder de forma coherente o responde sin relaci√≥n con lo presentado/documentado. Evidencia falta de comprensi√≥n b√°sica del trabajo entregado. | No se entregaron evidencias o no se puede acceder a ellas |
|Evaluaci√≥n||||||
---

:::tip[C√°lculo de la nota]

$$
Nota = C_1*0.4  + C_2*0.6
$$

:::

---

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

Vas a seguir practicando la t√©cnica de programaci√≥n con 
m√°quinas de estado y a transferirla a p5.js.

### Actividad 01

Regresemos a la actividad del sem√°foro de la unidad anterior. Te 
pedir√© que hagas las siguientes modificaciones:

1. Realiza un refactoring del c√≥digo. Implementa la aplicaci√≥n 
usando herencia implementando la clase sem√°foro as√≠:

```py
class Semaforo(FSMTask):
```

Recuerda que la clase `FSMTask` es la clase base para implementar m√°quinas de estado y 
est√° en el archivo fsm.py:

```py
import utime

ENTRY = "ENTRY"
EXIT  = "EXIT"

class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration
        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active and utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
            self.active = False
            self.owner.post_event(self.event)


class FSMTask:
    def __init__(self):
        self._q = []
        self._timers = []
        self._state = None

    def post_event(self, ev):
        self._q.append(ev)

    def add_timer(self, event, duration):
        t = Timer(self, event, duration)
        self._timers.append(t)
        return t

    def transition_to(self, new_state):
        if self._state:
            self._state(EXIT)
        self._state = new_state
        self._state(ENTRY)

    def update(self):
        for t in self._timers:
            t.update()
        while self._q:
            ev = self._q.pop(0)
            if self._state:
                self._state(ev)
```

2. Si el bot√≥n A se presiona el sem√°foro debe cambiar a modo "peatonal". 
En este modo el sem√°foro se pone en rojo, pero antes debe pasar por amarillo 
para darle tiempo a los autos a detenerse.

3. Si el bot√≥n B se presiona el sem√°foro pasa a modo nocturno. En este 
modo el sem√°foro parpadea en amarillo. Si el bot√≥n A se presiona en este modo, 
el sem√°foro vuelve a modo normal. 

### Actividad 02

Vas a modificar el c√≥digo del temporizador de la unidad anterior as√≠:

1. Si est√° corriendo el temporizador, al presionar el bot√≥n A se debe pausar el conteo.
Si se vuelve a presionar el bot√≥n A, el conteo se reanuda en donde se hab√≠a pausado.

2. Si el temporizador est√° corriendo, si se presiona una secuencia de botones A-B-A, 
el temporizador debo volver a modo de configuraci√≥n. 

## Seek: Investigaci√≥n üîé

### Actividad 03

Ahora vas a implementar el temporizador en p5.js usando la t√©cnica de m√°quinas de estado. 

## Apply: Aplicaci√≥n üõ†

### Actividad 04

Vas a modificar el c√≥digo anterior adicionando:

1. Si est√° corriendo el temporizador, al presionar la tecla A se debe pausar el conteo.
Si se vuelve a presionar la tecla A, el conteo se reanuda en donde se hab√≠a pausado.
2. Si el temporizador est√° corriendo, si se presiona una secuencia de teclas A-B-A, 
el temporizador debo volver a modo de configuraci√≥n. 
3. Vas a controlar el temporizador que est√° funcionando en p5.js usando el micro:bit, 
adem√°s de las teclas del computador. Recuerda que solo deber√°s usar del micro:bit los 
botones A y B y el aceler√≥metro.



## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

