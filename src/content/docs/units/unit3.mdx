---
title: Unidad 3
unitId: unit3
---

import { Aside } from '@astrojs/starlight/components';

<Aside type="danger">
NO USES IA PARA REALIZAR LAS ACTIVIDADES DE ESTA UNIDAD  

Lo que busco con esta unidad es que transformes tu cerebro mediante
un PROCESO cognitivo de experimentaci√≥n, observaci√≥n, reflexi√≥n y conclusi√≥n: 
INVESTIGACI√ìN EN ACCI√ìN. Lo que cambia tu cerebro no es el resultado, es el PROCESO.
</Aside>

## Introducci√≥n üìú

En esta unidad vas a seguir explorando la integraci√≥n entre micro:bit y p5.js,  
al tiempo que profundizar√°s en la t√©cnica de programaci√≥n con m√°quinas 
de estado. Volver√°s a practicar dicha t√©cnica con el micro:bit, pero 
tambi√©n en p5.js. 

Te preguntar√°s ¬øPor qu√© tanta insistencia del profe con esta t√©cnica? Y la 
raz√≥n es que ella te permitir√° lograr en tus aplicaciones escalabilidad, 
en t√©rminos de conconcurrencia, es decir, permitir√° que una aplicaci√≥n tenga 
m√∫ltiples **TAREAS** haciendo al mismo tiempo varias cosas.

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

Vas a seguir practicando la t√©cnica de programaci√≥n con m√°quinas de estado y a 
transferirla a p5.js.

### Actividad 01

#### Volvamos a la actividad del sem√°foro

En la unidad anterior construiste un sem√°foro con el micro:bit (cierto? pero si no o tu 
implementaci√≥n no estuvo bien, entonces tienes una nueva oportunidad). Ahora te pedir√© 
que hagas una modificaci√≥n. Esta vez construir√°s tres sem√°foros concurrente en el micro:bit. 

Cada uno de los sem√°foros tendr√° unos tiempos en rojo, amarillo y verde diferentes. Recuerda 
que el micro:bit tiene un solo display de 5x5 leds. Adem√°s, todos los leds son de color rojo. 
As√≠ que tendr√°s que ser creativo para representar los colores amarillo y verde.

Los tiempos para los sem√°foros ser√°n los siguientes:

- Sem√°foro 1: 5 segundos en rojo, 2 segundos en amarillo y 3 segundos en verde.
- Sem√°foro 2: 3 segundos en rojo, 1 segundo en amarillo y 2 segundos en verde.
- Sem√°foro 3: 4 segundos en rojo, 3 segundos en amarillo y 2 segundos en verde.

La estructura de tu programa ser√° similar a la siguiente:

``` py

class Semaforo:
    .
    .
    .

semaforo1 = Semaforo(...)
semaforo2 = Semaforo(...)
semaforo3 = Semaforo(...)

while True:
    semaforo1.update()
    semaforo2.update()
    semaforo3.update()
```

<details>

<summary>C√≥digo</summary>
``` py
# Imports go at the top
from microbit import *
import utime

display.clear()

class Semaforo:
    def __init__(self,x,y,tr,ty,tg):
        self.x = x
        self.y = y
        self.tr = tr
        self.ty =ty
        self.tg = tg
        self.startTime = utime.ticks_ms()
        self.state = 'WaitInRed'
        display.set_pixel(self.x,self.y,9)

    def update(self):
        if self.state == 'WaitInRed':
            if utime.ticks_diff(utime.ticks_ms(),self.startTime) >= self.tr:
                display.set_pixel(self.x,self.y,0)
                display.set_pixel(self.x,self.y+1,9)
                self.startTime = utime.ticks_ms()    
                self.state = 'WaitInYellow'
                
        elif self.state == 'WaitInYellow':
            if utime.ticks_diff(utime.ticks_ms(),self.startTime) >= self.ty:
                display.set_pixel(self.x,self.y+1,0)
                display.set_pixel(self.x,self.y+2,9)
                self.startTime = utime.ticks_ms()    
                self.state = 'WaitInGreen'
                
        elif self.state == 'WaitInGreen':
            if utime.ticks_diff(utime.ticks_ms(),self.startTime) >= self.tg:
                display.set_pixel(self.x,self.y+2,0)
                display.set_pixel(self.x,self.y,9)
                self.startTime = utime.ticks_ms()    
                self.state = 'WaitInRed'

semaforo1 = Semaforo(0,0,5000,2000,3000)
semaforo2 = Semaforo(1,0,3000,1000,2000)
semaforo3 = Semaforo(2,0,4000,3000,2000)

while True:
    semaforo1.update()
    semaforo2.update()
    semaforo3.update()

```

</details>

1. Qu√© ventajas tiene usar una **clase (class)** en este caso para representar 
un sem√°foro?

2. Puedes ver c√≥mo la t√©cnica de programaci√≥n con m√°quinas de estado y el uso de funciona 
no bloqueantes te permite que varios sem√°foros funcionen al mismo tiempo?


## Seek: Investigaci√≥n üîé

### Actividad 02

#### Bomba 2.0

La t√©cnica de m√°quina de estados no solo permite la concurrencia sino tambi√©n la escalabilidad 
en t√©rmino de nuevas funcionalidades.

Vas a retomar la bomba de la unidad anterior y le adicionar√°s algunas funcionalidades:

- Una vez la bomba est√© armada es posible desactivarla con la secuencia bot√≥n A, bot√≥n B, bot√≥n A. 
- Si la secuencia se ingresa correctamente la bomba pasar√° de nuevo al modo de configuraci√≥n de lo 
contrario continuar√° la fatal cuenta regresiva.

<details>

<summary>C√≥digo</summary>

``` py
# Imports go at the top
from microbit import *
import utime

display.clear()

class BombTask:
    def __init__(self):
        self.PASSWORD = ['A','B','A']
        self.key = ['']*len(self.PASSWORD)
        self.keyindex = 0
        self.count = 20
        self.startTime = utime.ticks_ms()
        self.state = 'CONFIG'
        display.clear()
        display.show(self.count,wait=False)

    def update(self):
        if self.state == 'CONFIG':
            if button_a.was_pressed():
                self.count = min(self.count+1,60)
                display.show(self.count,wait=False)
                
            if button_b.was_pressed():
                self.count = max(10,self.count-1)
                display.show(self.count, wait=False)

            if accelerometer.was_gesture('shake'):
                self.startTime = utime.ticks_ms()
                self.state = 'ARMED'
                
        elif self.state == 'ARMED':
            if utime.ticks_diff(utime.ticks_ms(),self.startTime) > 1000:
                self.startTime = utime.ticks_ms()
                self.count = self.count - 1
                display.show(self.count,wait=False)
                if self.count == 0:
                    display.show(Image.SKULL)
                    self.state = 'EXPLODED'
                    
            if button_a.was_pressed():
                self.key[self.keyindex] = 'A'
                self.keyindex = self.keyindex + 1

            if button_b.was_pressed():
                self.key[self.keyindex] = 'B'
                self.keyindex = self.keyindex + 1

            if self.keyindex == len(self.key):

                passIsOK = True
                for i in range(len(self.key)):
                    if self.key[i] != self.PASSWORD[i]:
                        passIsOK = False
                        break;
                if passIsOK == True:
                    self.count = 20
                    display.show(self.count,wait=False)
                    self.keyindex = 0
                    self.state = 'CONFIG'
                else:
                    self.keyindex = 0

        elif self.state == 'EXPLODED':
            if pin_logo.is_touched():
                self.count = 20
                display.show(self.count,wait=False)
                self.startTime = utime.ticks_ms()
                self.state = 'CONFIG'

bombTask = BombTask()

while True:
    bombTask.update()
```

</details>


### Actividad 03

#### Bomba 3.0

Seguiremos adicionando funcionalidades a la bomba.

- Adem√°s de controlar la bomba con los sensores del micro:bit, tambi√©n podr√°s 
controlarla desde el puerto serial, es decir, se controla desde dos fuentes 
diferentes.
- Debes hacer un refactoring a tu c√≥digo. La idea es que ahora la m√°quina 
de estados de la bomba no lea directamente los sensores del micro:bit, sino 
que reciba **EVENTOS GEN√âRICOS**. De esta manera, la m√°quina de estados
de la bomba no sabr√° de d√≥nde vienen los eventos, si del micro:bit o del puerto
serial. 

¬øC√≥mo puedes hacer esto? 

Puedes crear una variable que represente el evento que ocurri√≥. Cuando el evento 
ocurre escribes la variable con un valor representativo del evento. Adem√°s, esa 
variable debe tener un valor que indique que no ha ocurrido un evento.

Es importante que consumas el evento, es decir, una vez la m√°quina de estados
de la bomba reciba el evento, la variable que representa el evento debe tomar 
el valor que inidique que no hay evento.

Por ejemplo, la variable event tomar√° el valor 0 si no hay evento 
y 'A' si se presion√≥ el bot√≥n o se recibi√≥ la orden por el puerto serial.

En resumen: cada que ocurra un evento, debes almacenar el evento en la variable 
que lo represeta y cuando lo consumas debes borrarlo.

Estructura de tu programa as√≠:

``` py

class Event:
    .
    .
    .


class BombTask:
    .
    .
    .

class SerialTask:
    .
    .
    .

class ButtonTask:
    .
    .
    .


serial = SerialTask()
buttons = ButtonTask()
bomb = BombTask()

while True:
    serial.update()
    buttons.update()
    bomb.update() 
```

¬øC√≥mo enviar√°s los eventos del serial? 

Puedes usar [esta aplicaci√≥n](https://juanferfranco.github.io/serialTerminal/) que te permitir√° enviar 
datos por el puerto serial.

<details>

<summary>C√≥digo</summary>

``` py
# Imports go at the top
from microbit import *
import utime

display.clear()

class Event:
    def __init__(self):
        self.value = 0

    def set(self,_val):
        self.value = _val

    def clear(self):
        self.value = 0

    def read(self):
        return self.value

class SerialTask:
    def __init__(self):
        uart.init(baudrate=115200)
        
    def update(self):
        if uart.any():
            data = uart.read(1)
            if data:
                if data[0] == ord('A'):
                    event.set('A')
                elif data[0] == ord('B'):
                    event.set('B')
                elif data[0] == ord('S'):
                    event.set('S')
                elif data[0] == ord('T'):
                    event.set('T')


class ButtonTask:
    def __init__(self):
        pass

    def update(self):
        if button_a.was_pressed():
            event.set('A')
        elif button_b.was_pressed():
            event.set('B')
        elif accelerometer.was_gesture('shake'):
            event.set('S')
        elif pin_logo.is_touched():
            event.set('T')

class BombTask:
    def __init__(self):
        self.PASSWORD = ['A','B','A']
        self.key = ['']*len(self.PASSWORD)
        self.keyindex = 0
        self.count = 20
        self.startTime = utime.ticks_ms()
        self.state = 'CONFIG'
        display.clear()
        display.show(self.count,wait=False)

    def update(self):
        if self.state == 'CONFIG':
            if event.read() == 'A':
                event.clear()
                self.count = min(self.count+1,60)
                display.show(self.count,wait=False)
                
            if event.read() == 'B':
                event.clear()
                self.count = max(10,self.count-1)
                display.show(self.count, wait=False)

            if event.read() == 'S':
                event.clear()
                self.startTime = utime.ticks_ms()
                self.state = 'ARMED'
                
        elif self.state == 'ARMED':
            if utime.ticks_diff(utime.ticks_ms(),self.startTime) > 1000:
                self.startTime = utime.ticks_ms()
                self.count = self.count - 1
                display.show(self.count,wait=False)
                if self.count == 0:
                    display.show(Image.SKULL)
                    self.state = 'EXPLODED'
                    
            if event.read() == 'A':
                event.clear()
                self.key[self.keyindex] = 'A'
                self.keyindex = self.keyindex + 1

            if event.read() == 'B':
                event.clear()
                self.key[self.keyindex] = 'B'
                self.keyindex = self.keyindex + 1

            if self.keyindex == len(self.key):

                passIsOK = True
                for i in range(len(self.key)):
                    if self.key[i] != self.PASSWORD[i]:
                        passIsOK = False
                        break;
                if passIsOK == True:
                    self.count = 20
                    display.show(self.count,wait=False)
                    self.keyindex = 0
                    self.state = 'CONFIG'
                else:
                    self.keyindex = 0

        elif self.state == 'EXPLODED':
            if event.read() == 'T':
                event.clear()
                self.count = 20
                display.show(self.count,wait=False)
                self.startTime = utime.ticks_ms()
                self.state = 'CONFIG'

bombTask = BombTask()
serialTask = SerialTask()
buttonTask = ButtonTask()
event = Event()

while True:
    serialTask.update()
    buttonTask.update()
    bombTask.update()

```

</details>


### Actividad 04

#### Controla la bomba desde tu sketch en p5.js

En la actividad anterior controlaste la bomba desde una terminal serial. Ahora 
vas a controlar la bomba desde tu sketch en p5.js.

<details>

<summary>C√≥digo</summary>

``` js
let port;
let connectBtn;
let connectionInitialized = false;

let validChars = "ABST";

function setup() {
  createCanvas(400, 400);
  background(220);
  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(80, 300);
  connectBtn.mousePressed(connectBtnClick);
}

function draw() {
  background(220);
  if (port.opened() && !connectionInitialized) {
    port.clear();
    connectionInitialized = true;
  }

  textAlign(CENTER);
  text("Press A,B,S,T to simulate micro:bit keys", width / 2, height / 2);
  

  

  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
  } else {
    connectBtn.html("Disconnect");
  }
}

function keyPressed() {
  keyValue = key.toUpperCase();
  if(validChars.includes(keyValue)){
    console.log(keyValue);
    port.write(keyValue);
  } 
  
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
    connectionInitialized = false;
  } else {
    port.close();
  }
}

```

</details>

Como bonus a las actividades anteriores. ¬øQu√© debo hacer si quiero controlar 
la bomba desde el micro:bit, p5.js y desde un segundo micro:bit de manera inal√°mbrica, 
todo al mismo tiempo?

<details>
<summary>Respuesta</summary>
Este ser√≠a el c√≥digo para el control remoto:

``` py
from microbit import *
import radio

display.show(Image.HAPPY)

class RadioRemote:
    def __init__(self):
        radio.config(group=69)
        radio.on

    def update(self):
        if button_a.was_pressed():
            radio.send("A")
        if button_b.was_pressed():
            radio.send("B")
        if accelerometer.was_gesture("shake"):
            radio.send("S")
        if pin_logo.is_touched():
            radio.send("T")

radioRemote = RadioRemote()

while True:
    radioRemote.update()

```

Y este ser√≠a el c√≥digo del micro:bit modificado para soportar el control 
remoto:

``` py
from microbit import *
import utime
import radio

display.clear()

class Event:
    def __init__(self):
        self.value = 0

    def write(self,value):
        self.value = value

    def read(self):
        return self.value

    def clear(self):
        self.value = 0

class MicroBitSensors():
    def __init__(self):
        pass

    def update(self):
        if button_a.was_pressed():
            event.write("A")
        if button_b.was_pressed():
            event.write("B")
        if accelerometer.was_gesture("shake"):
            event.write("S")
        if pin_logo.is_touched():
            event.write("T")

class RemoteTask:
    def __init__(self):
        uart.init(baudrate=115200)

    def update(self):
        if uart.any():
            data = uart.read(1)
            if data:
                if data[0] == ord('A'):
                    event.write("A")
                if data[0] == ord('B'):
                    event.write("B")
                if data[0]== ord('S'):
                    event.write("S")
                if data[0] == ord('T'):
                    event.write("T")


class RadioRemote:
    def __init__(self):
        radio.config(group=69)
        radio.on

    def update(self):
        message = radio.receive()
        if message:
            if message == "A":
                event.write("A")
            elif message == "B":
                event.write("B")    
            elif message == "S":
                event.write("S")
            elif message == "T":
                event.write("T")


class BombTask:
    def __init__(self):
        self.PASSWORD = ['A','B','A']
        self.key = ['']*len(self.PASSWORD)
        self.keyindex = 0
        self.count = 20
        self.startTime = utime.ticks_ms()
        self.state = 'CONFIG'
        display.clear()
        display.show(self.count,wait=False)

    def update(self):
        if self.state == 'CONFIG':
            if event.read()== "A":
                event.clear()
                self.count = min(self.count+1,60)
                display.show(self.count,wait=False)

            if event.read()== "B":
                event.clear()
                self.count = max(10,self.count-1)
                display.show(self.count, wait=False)

            if event.read()== "S":
                event.clear()
                self.startTime = utime.ticks_ms()
                self.state = 'ARMED'

        elif self.state == 'ARMED':
            if utime.ticks_diff(utime.ticks_ms(),self.startTime) > 1000:
                self.startTime = utime.ticks_ms()
                self.count = self.count - 1
                display.show(self.count,wait=False)
                if self.count == 0:
                    display.show(Image.SKULL)
                    self.state = 'EXPLODED'

            if event.read()== "A":
                event.clear()
                self.key[self.keyindex] = 'A'
                self.keyindex = self.keyindex + 1

            if event.read()== "B":
                event.clear()
                self.key[self.keyindex] = 'B'
                self.keyindex = self.keyindex + 1

            if self.keyindex == len(self.key):

                passIsOK = True
                for i in range(len(self.key)):
                    if self.key[i] != self.PASSWORD[i]:
                        passIsOK = False
                        break;
                if passIsOK == True:
                    self.count = 20
                    display.show(self.count,wait=False)
                    self.keyindex = 0
                    self.state = 'CONFIG'
                else:
                    self.keyindex = 0

        elif self.state == 'EXPLODED':
            if event.read()== "T":
                event.clear()
                self.count = 20
                display.show(self.count,wait=False)
                self.startTime = utime.ticks_ms()
                self.state = 'CONFIG'

bombTask = BombTask()
event = Event()
sensors = MicroBitSensors()
remoteTask = RemoteTask()
radioRemote = RadioRemote()

while True:
    radioRemote.update()
    remoteTask.update()
    sensors.update()
    bombTask.update()

```

</details>


### Actividad 05

#### Es momento de modelar la bomba y definir vectores de prueba

Ahora es momento de modelar la bomba con una m√°quina de estados y definir una 
tabla con vectores de prueba.

:::caution[üì§ Bit√°cora] 
1. Construye el modelo de la bomba 3.0. Como ya tienes el c√≥digo puedes tener un modelo
muy preciso.
2. Crear una tabla con los vectores de prueba. La tabla debe tener 4 columnas por vector y 
puedes agrupar vectores en un gran vector. Las columnas son:
   - Estado inicial
   - Evento disparador
   - Acciones
   - Estado final
:::

## Apply: Aplicaci√≥n üõ†

### Actividad 06

#### Crear la bomba en p5.js

En esta actividad vas a transferir la t√©cnica de programaci√≥n con m√°quinas de estado a p5.js. 

Crea la bomba versi√≥n 2.0 en p5.js. No olvides que al aplicar la t√©cnica de m√°quinas de estado 
en micro:bit se evitaba colocar acciones por fuera de los eventos. En el caso de p5.js ser√° 
necesario que tengas acciones por fuera de eventos porque es necesario dibujar el canvas 
en cada frame.

:::caution[üì§ Bit√°cora] 

NO GENERES C√ìDIGO CON IA. Este es un ejercicio de transferencia de aprendizaje. Ya sabes 
la t√©cnica de programaci√≥n con m√°quinas de estado y c√≥mo se aplica en el micro:bit. Ahora debes 
transferir ese conocimiento a p5.js.

1. El c√≥digo fuente de la bomba en p5.js. No olvides el prop√≥sito de esta evaluaci√≥n: utilizar la 
t√©cnica de m√°quina de estados que estamos trabajando en el curso.
:::

### Actividad 07

#### Bomba en p5.js + controles del micro:bit

Vas a practicar de nuevo la t√©cnica de m√°quina de estados y eventos gen√©ricos, pero esta vez
vas a controlar la bomba desde el micro:bit y desde p5.js. TEN PRESENTE que la bomba estar√° 
corriendo en p5.js, pero deber√°s controlarla tambi√©n desde los botones del micro:bit mediante 
el puerto serial.


:::caution[üì§ Bit√°cora] 

NO GENERES C√ìDIGO CON IA. Este es un ejercicio de transferencia de aprendizaje. Ya sabes 
la t√©cnica de programaci√≥n con m√°quinas de estado y c√≥mo se aplica en el micro:bit. Ahora debes 
transferir ese conocimiento a p5.js.

1. C√≥digo p5.js 
2. Enlace al editor de p5.js con tu c√≥digo.
3. C√≥digo del micro:bit.
:::


## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

### Actividad 08

#### Autoevaluaci√≥n

El objetivo aqu√≠ es doble. Primero, que recuperes de tu memoria los conceptos de dise√±o y 
programaci√≥n con m√°quinas de estados sin ayuda externa. Este esfuerzo por recordar 
(pr√°ctica de recuperaci√≥n) es clave para un aprendizaje duradero. Segundo, que reflexiones 
sobre tu proceso de dise√±o y depuraci√≥n, una habilidad esencial para cualquier ingeniero.

:::caution[üì§ Bit√°cora]

En tu bit√°cora, sin consultar tu c√≥digo, diagramas o notas, responde a las siguientes preguntas con 
us propias palabras. Conc√©ntrate en el esfuerzo de recordar, no en la perfecci√≥n de la respuesta.

**Parte 1: recuperaci√≥n de conocimiento (Retrieval Practice)**

1.  Describe con tus palabras qu√© es una m√°quina de estados. ¬øCu√°les son sus cuatro componentes 
fundamentales que has utilizado en esta unidad?
2.  Explica por qu√© la t√©cnica de m√°quina de estados es tan √∫til para gestionar la "concurrencia" 
(atender varios eventos y tareas "al mismo tiempo") en un dispositivo con un solo hilo de ejecuci√≥n 
como el micro:bit o en p5.js. ¬øQu√© problema soluciona en comparaci√≥n con usar funciones como `sleep()`?
3.  Imagina que tienes que a√±adir una nueva funcionalidad a la bomba: si se recibe un evento 
especial (por ejemplo, una combinaci√≥n de botones o un comando serial) *mientras* la cuenta 
regresiva est√° activa, el tiempo se reduce a la mitad. ¬øC√≥mo modificar√≠as tu diagrama de m√°quina 
de estados para incluir este nuevo evento y acci√≥n?
4.  Explica qu√© es un "vector de prueba" y por qu√© es una herramienta crucial para verificar que 
una m√°quina de estados funciona como se espera.

**Parte 2: reflexi√≥n sobre tu proceso (Metacognici√≥n)**

1.  ¬øQu√© parte del dise√±o de la bomba te result√≥ m√°s desafiante: crear el diagrama de estados o 
traducir ese diagrama a c√≥digo? ¬øPor qu√©?
2.  Describe un error o "bug" que encontraste al implementar tu programa. ¬øC√≥mo te ayud√≥ pensar en 
t√©rminos de estados, eventos y transiciones a identificar y solucionar el problema?
3.  El problema de la bomba era complejo. ¬øQu√© estrategia usaste para abordarlo? ¬øComenzaste 
con una versi√≥n simple y a√±adiste funcionalidades poco a poco?
4.  Ahora que entiendes el patr√≥n de m√°quina de estados, ¬øEn qu√© otro tipo de proyecto o 
sistema de entretenimiento digital crees que podr√≠as aplicarlo?
:::

### Actividad 09

#### Feedback

Mi objetivo es crear la mejor experiencia de aprendizaje posible, y tu perspectiva es esencial para 
lograrlo. Este es tu espacio para darme feedback honesto y directo sobre esta unidad, lo que me 
ayudar√° a refinarla para futuros estudiantes.

:::caution[üì§ Bit√°cora]

Responde a las siguientes preguntas con total sinceridad. ¬°Cada comentario es valioso!

1.  **Continuar**: ¬øQu√© actividad, explicaci√≥n o ejemplo de esta unidad te ayud√≥ m√°s a entender el poder de 
las m√°quinas de estados? ¬øQu√© elemento consideras que es indispensable y deber√≠a mantener?
2.  **Dejar de hacer**: ¬øHubo alg√∫n paso o actividad que te pareci√≥ confuso? ¬øQu√© cambiar√≠as o eliminar√≠as?
3.  **Empezar a hacer**: ¬øQu√© te habr√≠a ayudado a entender mejor?
4.  **Ritmo y dificultad**: En una escala del 1 (muy f√°cil) al 5 (muy dif√≠cil), ¬øC√≥mo calificar√≠as la 
dificultad de pasar del an√°lisis de un programa a dise√±ar y programar uno complejo? ¬øPor qu√©?
5.  **Comentario adicional**: ¬øHay algo m√°s que te gustar√≠a compartir sobre tu proceso de aprendizaje en 
esta unidad? ¬øAlg√∫n momento de frustraci√≥n o de "¬°Aha!" que quieras destacar?
:::
