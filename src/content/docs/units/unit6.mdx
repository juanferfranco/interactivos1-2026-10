---
title: Unidad 6
unitId: unit6
---

import { Aside } from '@astrojs/starlight/components';


## IntroducciÃ³n ğŸ“œ

Hasta ahora, has aprendido a conectar dispositivos fÃ­sicos a tus aplicaciones 
interactivas usando comunicaciÃ³n serial. En esta unidad, vamos a explorar cÃ³mo
conectar dos aplicaciones que se ejecutan en tu navegador en tiempo real.

## Set: Â¿QuÃ© aprenderÃ¡s en esta unidad? ğŸ’¡

En esta unidad, descubrirÃ¡s Node.js y Socket.IO, herramientas poderosas que nos 
permitirÃ¡n crear un "puente" de comunicaciÃ³n. Node.js actuarÃ¡ como un servidor 
intermediario, y Socket.IO facilitarÃ¡ el envÃ­o y recepciÃ³n de mensajes instantÃ¡neos 
entre las aplicaciones cliente (sketches de p5.js). Empezaremos analizando un caso 
de estudio funcional para entender la mecÃ¡nica servidor-cliente y luego lo 
modificarÃ¡s para crear tu propia experiencia interactiva conectada. Aunque en esta 
unidad ambas aplicaciones cliente correrÃ¡n en tu computador, esto sienta las bases 
para futuras conexiones entre diferentes dispositivos o computadores.

**Â¿QuÃ© aprenderÃ¡s?**

- ConfigurarÃ¡s y ejecutarÃ¡s un servidor bÃ¡sico usando Node.js, Express y Socket.IO.  
- ImplementarÃ¡s una comunicaciÃ³n en tiempo real entre dos sketches de p5.js utilizando 
Socket.IO a travÃ©s de un servidor Node.js.  
- AnalizarÃ¡s la arquitectura cliente-servidor y el flujo de datos en una aplicaciÃ³n 
web en tiempo real.  
- Partiendo de la infraestructura de comunicaciÃ³n propuesta por un caso de estudio existente, 
crearÃ¡s una nueva aplicaciÃ³n interactiva que utilice comunicaciÃ³n en red.

### Actividad 01 

#### PreparaciÃ³n del entorno y primer contacto

:::note[ğŸ¯ Enunciado]
Antes de sumergirnos en el cÃ³digo, vamos a preparar nuestro 
entorno de desarrollo y ejecutar el caso de estudio base. Es crucial entender 
cÃ³mo poner en marcha el sistema completo.
:::

:::tip[Recursos]
NecesitarÃ¡s tener [Node.js](https://nodejs.org/en) instalado en tu sistema. 
Los computadores de la U ya lo tienen, pero si estÃ¡s trabajando en tu computador personal tendrÃ¡s 
que instalarlo primero.

Descarga o clona el cÃ³digo fuente del caso de estudio desde [este repositorio](https://github.com/juanferfranco/entangledTest-sfi1-2025-20)
:::

ğŸ‘£ **Pasos**:

:::note[ğŸ”§ ConfiguraciÃ³n del entorno]
- Abre una terminal o sÃ­mbolo del sistema en tu computador.  
- Navega (usando el comando cd) hasta la carpeta donde descargaste/clonaste el cÃ³digo fuente.  
- Ejecuta el comando: 

    ``` bash
    npm install
    ```  
- Una vez que termine la instalaciÃ³n, ejecuta el comando: 
    
    ``` bash
    npm start
    ```  
- Ten presente que el paso npm install solo es necesario la primera vez que trabajas con el proyecto.
- Observa la salida en la terminal. DeberÃ­as ver un mensaje indicando que el servidor estÃ¡ escuchando.
- Abre tu navegador web, te recomiendo usar Chrome o Edge.
- En una ventana, escribe la direcciÃ³n: http://localhost:3000/page1
- En otra ventana del mismo navegador, escribe la direcciÃ³n: http://localhost:3000/page2
- InteractÃºa con las ventanas (muÃ©velas si tu sistema operativo lo permite, observa los elementos visuales).
:::

:::note[ğŸ§ğŸ§ªâœï¸ Reporta en tu bitÃ¡cora]

- Â¿QuÃ© ocurriÃ³ en la terminal cuando ejecutaste npm install? 
Â¿CuÃ¡l crees que es su propÃ³sito?  
- Â¿QuÃ© mensaje especÃ­fico apareciÃ³ en la terminal despuÃ©s de 
ejecutar npm start? Â¿QuÃ© indica este mensaje?  
- Describe lo que ves inicialmente en page1 y page2 en tu navegador.
- Â¿QuÃ© mensajes aparecieron en la terminal del servidor cuando abriste page1 y page2?
- Describe quÃ© sucede en ambas pÃ¡ginas del navegador cuando mueves una de las 
ventanas. Â¿Cambia algo visualmente? Â¿QuÃ© mensajes aparecen (si los hay) en la 
consola del navegador (usualmente accesible con F12 -> PestaÃ±a Consola) y en 
la terminal del servidor?
:::

## Seek: InvestigaciÃ³n ğŸ”

### Actividad 02

:::note[ğŸ¯ Enunciado]
Antes de sumergirnos en el cÃ³digo especÃ­fico de nuestro caso de estudio,
vamos a hacer un viaje conceptual. 
:::

---

**Â¿QuÃ© es Internet?**

Imagina Internet no como una "nube" etÃ©rea, sino como una **gigantesca red de carreteras y cables**
conectando millones de lugares: bibliotecas, tiendas, oficinas, casas... y tambiÃ©n unos lugares
especiales llamados `Servidores`. Tu computador (o telÃ©fono) es tu vehÃ­culo, conectado a
estas carreteras.

:::caution[ğŸ§âœï¸ Reporta en tu bitÃ¡cora]
Piensa en cÃ³mo te conectas a Internet en casa o en la Universidad.
Â¿Usas Wi-Fi? Â¿Un cable de red? Eso es simplemente tu "rampa de acceso" a la gran red de
carreteras. Â¿QuÃ© pasarÃ­a si esa rampa se corta? Anota tus ideas.
:::

---

**Navegador y servidor**

Tu **navegador web** (Chrome, Firefox, Safari, Edge...) es tu vehÃ­culo sÃºper inteligente. No
solo te lleva por las carreteras (Internet), sino que sabe cÃ³mo pedir cosas y, lo mÃ¡s
importante, Â¡CÃ³mo mostrarte lo que recibe! Eres tÃº, el usuario, quien decide a
dÃ³nde ir. TÃº eres el **Cliente**.

Un **Servidor** es como una biblioteca o un almacÃ©n gigante abierto 24/7, ubicado en algÃºn
punto de esa red de carreteras. Su trabajo principal es *"servir"* informaciÃ³n o funcionalidad
cuando un `Cliente` (como tu navegador) se la pide correctamente.

> **La base:** el **modelo Cliente-Servidor** = el `Cliente` pide, el `Servidor` responde.

:::caution[ğŸ§âœï¸ Reporta en tu bitÃ¡cora]
Â¿Puedes identificar otros ejemplos de relaciones `Cliente-Servidor` en
tu vida diaria (no necesariamente digitales)? Por ejemplo, al pedir comida en un restaurante.
Â¿QuiÃ©n es el cliente y quiÃ©n el servidor? Â¿QuÃ© se pide y quÃ© se entrega?
:::

---

**Â¿QuÃ© es una URL?**

Para que tu Navegador sepa a quÃ© `Servidor` especÃ­fico ir dentro de esa inmensa red, necesita
una direcciÃ³n precisa. Esa direcciÃ³n es la **URL** (Uniform Resource Locator).

Desglosemos una URL tÃ­pica: `http://www.ejemplo.com/pagina/index.html`

*   **`http://`**
    *   El **protocolo**. Son las reglas del idioma que usarÃ¡n tu navegador y el servidor para hablar. Â¡Volveremos a esto!
*   **`www.ejemplo.com`**
    *   El **nombre de dominio**. Es como el nombre del edificio o de la biblioteca. DetrÃ¡s de escena, este nombre se traduce 
    a una direcciÃ³n numÃ©rica (la `direcciÃ³n IP`) que sÃ­ indica la ubicaciÃ³n fÃ­sica en la red.
*   **`/pagina/index.html`**
    *   La **ruta especÃ­fica** dentro de ese servidor. Es como pedir ir a la "secciÃ³n de arte, Estante 3, Libro 5" dentro de 
    la biblioteca. Indica el recurso exacto que quieres.

:::caution[ğŸ§âœï¸ Reporta en tu bitÃ¡cora]
Toma la URL de tu sitio web favorito. Intenta identificar el protocolo,
el nombre de dominio y la ruta (si la hay). Â¿QuÃ© crees que pasa si solo escribes el nombre de
dominio (ej. `www.google.com`) sin una ruta especÃ­fica? Â¿QuÃ© "pÃ¡gina por defecto" crees que
te envÃ­a el servidor?
:::

---

**Protocolo HTTP**

Dijimos que `http` era el protocolo. Â¿Pero quÃ© significa eso? Recuerda las unidades anteriores
donde usaste protocolos (`ASCII`, binario con `framing`) para que el micro:bit y p5.js se entendieran
por el puerto serial. Â¡AquÃ­ es la misma idea, pero a gran escala!

**HTTP (HyperText Transfer Protocol)** es el conjunto de reglas estÃ¡ndar que usan los Navegadores
(`Clientes`) y los `Servidores` para comunicarse en la web. Es como un idioma formal:

```text
--- INICIO DE LA CONVERSACIÃ“N HTTP ---

â¡ï¸  Navegador (Cliente) envÃ­a una PeticiÃ³n HTTP (HTTP Request):
    "Â¡Hola servidor en www.ejemplo.com!
     SOY un navegador Chrome.
     POR FAVOR, Â¿me puedes dar (mÃ©todo GET) el recurso que estÃ¡ en /pagina/index.html?"

â¬…ï¸  Servidor responde con una Respuesta HTTP (HTTP Response):
    "Â¡Entendido, Navegador!
     AQUÃ TIENES (CÃ³digo de estado 200 OK).
     El archivo que pediste (index.html) es de tipo HTML (Content-Type).
     AquÃ­ estÃ¡n sus contenidos: <html>...</html>"

--- FIN DE LA CONVERSACIÃ“N HTTP ---
```

:::caution[ğŸ§âœï¸ Reporta en tu bitÃ¡cora]
Compara HTTP con los protocolos seriales que usaste.

Â¿QuÃ© similitudes encuentras?

Â¿QuÃ© diferencias clave ves?

Â¿Por quÃ© crees que HTTP necesita ser mÃ¡s complejo que un simple envÃ­o de bytes como hacÃ­as con el micro:bit?
:::

---

**HTML, CSS y JavaScript**

Cuando el servidor responde con Ã©xito a una peticiÃ³n de una pÃ¡gina web, normalmente no
envÃ­a una sola cosa, sino un *"paquete"* con instrucciones para tu Navegador. Este paquete
suele contener tres tipos principales de archivos:

*   **HTML** (HyperText Markup Language):
    *   **El esqueleto**, la estructura de la pÃ¡gina.
    *   Define *quÃ©* elementos hay: tÃ­tulos, pÃ¡rrafos, imÃ¡genes, botones, etc.
    *   *AnalogÃ­a:* el plano de una casa.
*   **CSS** (Cascading Style Sheets):
    *   **La decoraciÃ³n**, el estilo visual.
    *   Define *cÃ³mo se ven* esos elementos: colores, fuentes, tamaÃ±os, posiciones.
    *   *AnalogÃ­a:* la pintura, los muebles y las cortinas de la casa.
*   **JavaScript (JS)**:
    *   **La interactividad**, la "magia" que hace que la pÃ¡gina responda a tus acciones.
    *   *Puede* cambiar el `HTML` y el `CSS` dinÃ¡micamente, reaccionar a clics, enviar datos, Â¡Y mucho mÃ¡s!
    *   *AnalogÃ­a:* la electricidad, la plomerÃ­a y los electrodomÃ©sticos que hacen la casa funcional y habitable.

:::caution[ğŸ§âœï¸ Reporta en tu bitÃ¡cora]
Piensa en una pÃ¡gina web simple, como un formulario de login.
*   Â¿QuÃ© parte crees que es `HTML` (ej. los campos de texto, el botÃ³n)?
*   Â¿QuÃ© parte es `CSS` (ej. el color del botÃ³n, el tipo de letra)?
*   Â¿QuÃ© parte es `JavaScript` (ej. la comprobaciÃ³n de si escribiste algo antes de enviar, el mensaje de "contraseÃ±a incorrecta" que aparece sin recargar la pÃ¡gina)?
:::

---

**Â¿CÃ³mo se ejecuta JavaScript?**

El Navegador recibe el `HTML`, lo lee y construye la estructura bÃ¡sica de la pÃ¡gina (el **DOM** - Document Object Model). Luego aplica los estilos del `CSS`. Pero, 
Â¿CuÃ¡ndo y cÃ³mo entra en juego el `JavaScript`?

Normalmente, el `HTML` incluye etiquetas `<script>` que le dicen al navegador: `"Oye, aquÃ­ hay cÃ³digo JavaScript, por favor, ejecÃºtalo"`. Esto puede pasar:

*   **Mientras se carga la pÃ¡gina:** si el `<script>` estÃ¡ en medio del `HTML`, el navegador *pausa* la construcciÃ³n, ejecuta el `JS` y luego sigue.
*   **DespuÃ©s de cargar el HTML:** a menudo, los scripts se colocan al final del `<body>` o se marcan con atributos como `defer` o `async` para que se ejecuten 
*despuÃ©s* de que la estructura principal (`DOM`) estÃ© lista. Â¡Esto es importante para que el `JS` pueda encontrar y manipular los elementos `HTML`!

Una vez que el `JS` estÃ¡ "vivo", no se ejecuta necesariamente de arriba abajo y termina (como un script simple). En la web, el `JS` a menudo funciona de 
forma **dirigida por eventos**.

---

**El Modelo de ejecuciÃ³n: imperativo vs basado en eventos**

Has estado usando p5.js. Recuerda las funciones `setup()` (se ejecuta una vez) y `draw()` (se ejecuta en bucle constante, ~60 veces por segundo). Este es un modelo 
bastante **imperativo**: tÃº le dices al programa quÃ© hacer paso a paso, y `draw()` repite esos pasos continuamente.

El `JavaScript` que veremos en el caso de estudio (y en mucha programaciÃ³n web moderna) es mÃ¡s **declarativo y basado en eventos**. En lugar de un bucle `draw()` constante, defines funciones y luego le dices al navegador:

> "CUANDO el usuario haga clic en este botÃ³n, ENTONCES ejecuta `estaFuncion()`".
>
> "CUANDO llegue un mensaje del servidor con el nombre `getdata`, ENTONCES ejecuta `otraFuncion()`".
>
> "CUANDO la ventana cambie de tamaÃ±o, ENTONCES ejecuta `aquellaFuncion()`".

El cÃ³digo no se ejecuta en un bucle predecible, sino que **reacciona a eventos** que ocurren. El navegador se encarga de detectar esos eventos y llamar 
a las funciones que tÃº registraste (llamadas *event listeners* o *manejadores de eventos*).

:::caution[ğŸ§âœï¸ Reporta en tu bitÃ¡cora]
Compara el bucle `draw()` de p5.js con este modelo de "esperar a que algo pase y reaccionar".
*   Â¿QuÃ© ventajas crees que tiene el modelo basado en eventos para una interfaz de usuario web?
*   Â¿SerÃ­a eficiente tener un bucle `draw()` redibujando toda la pÃ¡gina 60 veces por segundo si nada ha cambiado?
:::

---

**Â¿QuÃ© es Node.js?**

Hasta ahora (en el curso), `JavaScript` vivÃ­a solo dentro de tu Navegador. **Node.js** fue una idea revolucionaria que cambiÃ³ eso. 
Â¿Y si pudiÃ©ramos tomar el motor de JavaScript sÃºper rÃ¡pido de Google Chrome (llamado `V8`) y usarlo *fuera* del navegador, directamente en un `Servidor`?

Â¡Eso es `Node.js`! Permite a los desarrolladores escribir el cÃ³digo del **lado del servidor** usando `JavaScript`, el mismo lenguaje que ya usan en el 
**lado del cliente** (navegador). En nuestro caso de estudio, `server.js` es un script de `Node.js` que:

*   Crea un servidor `HTTP` (como la biblioteca con la secciÃ³n de historia de la que hablamos antes).
*   Escucha peticiones de los navegadores (como la tuya pidiendo `/page1`).
*   EnvÃ­a los archivos `HTML`, `CSS` y `JS` necesarios.
*   Y ademÃ¡s, maneja la comunicaciÃ³n en tiempo real (Â¡Siguiente punto!).

:::caution[ğŸ§âœï¸ Reporta en tu bitÃ¡cora]
Â¿Por quÃ© crees que podrÃ­a ser Ãºtil usar `JavaScript` tanto en el cliente (navegador) como en el servidor? Â¿Se te ocurre alguna ventaja para los desarrolladores?
:::

---

**WebSockets y Socket.IO**

El modelo `HTTP` normal de PeticiÃ³n/Respuesta es como *enviar correos electrÃ³nicos*: pides algo, esperas, recibes una respuesta. Funciona bien para 
pedir pÃ¡ginas web, pero Â¿QuÃ© pasa si quieres **comunicaciÃ³n instantÃ¡nea**, como un chat o ver la posiciÃ³n del cursor de otra persona en tiempo real? 
Enviar un "correo" (`HTTP Request`) cada dÃ©cima de segundo serÃ­a muy ineficiente.

AquÃ­ entran los **WebSockets**. Son como establecer una *lÃ­nea telefÃ³nica directa y permanente* entre el Navegador (`Cliente`) y el `Servidor` 
una vez que la conexiÃ³n inicial se ha hecho. Una vez abierta, ambos pueden enviarse mensajes instantÃ¡neamente sin necesidad de nuevas peticiones `HTTP` formales.

**Socket.IO** es una librerÃ­a (tanto para `Node.js` en el servidor como para `JavaScript` en el navegador) que hace que usar `WebSockets` (y otras tÃ©cnicas de 
respaldo si `WebSockets` no estÃ¡ disponible) sea mucho mÃ¡s fÃ¡cil. Nos da funciones simples como:

*   `socket.on('nombreDelMensaje', funcionReceptora)`: para **escuchar** mensajes del otro lado.
*   `socket.emit('nombreDelMensaje', datosAEnviar)`: para **enviar** mensajes al otro lado.

:::caution[ğŸ§âœï¸ Reporta en tu bitÃ¡cora]
Resume con tus propias palabras la diferencia fundamental entre una comunicaciÃ³n `HTTP` tradicional y una comunicaciÃ³n usando `WebSockets`/`Socket.IO`. Â¿En 
quÃ© tipo de aplicaciones has visto o podrÃ­as imaginar que se usa esta comunicaciÃ³n en tiempo real?
:::

---

### Actividad 03

:::note[ğŸ¯ **Enunciado**]
Analizaremos juntos el cÃ³digo del servidor [`server.js`](https://github.com/juanferfranco/entangledTest-sfi1-2025-20/blob/main/server.js) lÃ­nea por lÃ­nea.
:::

:::caution[ğŸ§ğŸ§ªâœï¸ Experimenta]

- DetÃ©n el servidor si estÃ¡ corriendo.

- Cambia la primera ruta de /page1 a /pagina_uno.

- Inicia el servidor.

- Intenta acceder a http://localhost:3000/page1. Â¿Funciona?

- Ahora intenta acceder a http://localhost:3000/pagina_uno. Â¿Funciona?

- Â¿QuÃ© te dice esto sobre cÃ³mo el servidor asocia URLs con respuestas? Restaura el cÃ³digo.
:::


:::caution[ğŸ§ğŸ§ªâœï¸ **Experimenta**]

- AsegÃºrate de que el servidor estÃ© corriendo (npm start).

- Abre http://localhost:3000/page1 en una pestaÃ±a. Observa la terminal del servidor. Â¿QuÃ© mensaje ves? Anota el ID.

- Abre http://localhost:3000/page2 en OTRA pestaÃ±a. Observa la terminal. Â¿QuÃ© mensaje ves? Â¿El ID es diferente?

- Cierra la pestaÃ±a de page1. Observa la terminal. Â¿QuÃ© mensaje ves? Â¿Coincide el ID con el que anotaste?

- Cierra la pestaÃ±a de page2. Observa la terminal.
:::


:::caution[ğŸ§ğŸ§ªâœï¸ **Experimenta**]

- Inicia el servidor y abre page1 y page2.

- Mueve la ventana de page1. Observa la terminal del servidor. Â¿QuÃ© evento se registra 
(win1update o win2update)? Â¿QuÃ© datos (Data:) ves?

- Mueve la ventana de page2. Observa la terminal. Â¿QuÃ© evento se registra ahora? Â¿QuÃ© datos ves?

- Experimento clave: cambia socket.broadcast.emit('getdata', page1); por 
socket.emit('getdata', page1); (quitando broadcast). Reinicia el servidor, abre ambas pÃ¡ginas. 
Mueve page1. Â¿Se actualiza la visualizaciÃ³n en page2? Â¿Por quÃ© sÃ­ o por quÃ© no? 
(Pista: Â¿A quiÃ©n le envÃ­a el mensaje socket.emit?). Restaura el cÃ³digo a broadcast.emit.
:::

:::caution[ğŸ§ğŸ§ªâœï¸ Experimenta]

- DetÃ©n el servidor.

- Cambia const port = 3000; a const port = 3001;.

- Inicia el servidor. Â¿QuÃ© mensaje ves en la consola? Â¿En quÃ© puerto dice que estÃ¡ escuchando?

- Intenta abrir http://localhost:3000/page1. Â¿Funciona?

- Intenta abrir http://localhost:3001/page1. Â¿Funciona?

- Â¿QuÃ© aprendiste sobre la variable port y la funciÃ³n listen? Restaura el puerto a 3000.
:::

### Actividad 04

#### Explorando los clientes (p5.js + Socket.IO)

:::note[ğŸ¯ **Enunciado**] 
Ahora nos enfocaremos en cÃ³mo uno de los clientes, [page2.js](https://github.com/juanferfranco/entangledTest-sfi1-2025-20/blob/main/views/page2.js), 
interactÃºa con el servidor y visualiza la informaciÃ³n. El cÃ³digo de page1.js es 
muy similar, asÃ­ que entender uno te ayudarÃ¡ a entender el otro.
:::


:::caution[ğŸ§ğŸ§ªâœï¸ **Experimenta**]

- Abre page2.html en tu navegador (con el servidor corriendo).

- Abre la consola de desarrollador (F12).

- DetÃ©n el servidor Node.js (Ctrl+C).

- Refresca la pÃ¡gina page2.html. Observa la consola del navegador. Â¿Ves algÃºn error relacionado con la conexiÃ³n? Â¿QuÃ© indica?

- Vuelve a iniciar el servidor y refresca la pÃ¡gina. Â¿Desaparecen los errores?
:::

:::caution[ğŸ§ğŸ§ªâœï¸ **Experimenta**]

- Comenta la lÃ­nea socket.emit('win2update', currentPageData, socket.id); dentro del listener connect.

- Reinicia el servidor y refresca page1.html y page2.html.

- Mueve la ventana de page2 un poco para que envÃ­e una actualizaciÃ³n.

- Â¿QuÃ© pasÃ³? Â¿Por quÃ©?
:::

:::caution[ğŸ§ğŸ§ªâœï¸ **Experimenta**]

- Abre ambas pÃ¡ginas (es posible que ya las tengas abiertas).

- Mueve la ventana de page1. Observa la consola del navegador de page2. Â¿QuÃ© datos muestra?

- Mueve la ventana de page2. Observa la consola de page1. Â¿QuÃ© pasa? Â¿Por quÃ©?
:::


:::caution[ğŸ§ğŸ§ªâœï¸ **Experimenta**]

- Observa checkWindowPosition() en page2.js y modifica el cÃ³digo del if para comprobar 
si el cÃ³digo dentreo de este se ejecuta.
- Mueve cada ventana y observa las consolas.
- Â¿QuÃ© puedes concluir y por quÃ©?
:::

:::caution[ğŸ§ğŸ§ªâœï¸ **Experimenta** (Â¡SÃ© creativo!)]

- Cambia el background(220) para que dependa de la distancia entre las ventanas. Puedes calcular la 
magnitud del resultingVector usando let distancia = resultingVector.mag(); y luego usa map() para 
convertir esa distancia a un valor de gris o color. background(map(distancia, 0, 1000, 255, 0)); 
(ajusta el rango 0-1000 segÃºn sea necesario).

- Inventa otra modificaciÃ³n creativa.
:::

## Apply: AplicaciÃ³n ğŸ› 

### Actividad 05

:::note[ğŸ¯ **Enunciado**] 
Basado en la infraestructura de comunicaciÃ³n del caso de estudio vas a crear tu 
propia aplicaciÃ³n interactiva en tiempo real. DiseÃ±o algo completamente nuevo usando la 
misma tecnologÃ­a de comunicaciÃ³n. Â¡SÃ© creativo! Quiero insistirte con algo. No se trata de solo cambiar 
el diseÃ±o o la apariencia de la aplicaciÃ³n. Se trata de crear algo nuevo, diferente y original.
:::

:::caution[ğŸ§ğŸ§ªâœï¸ En tu bitÃ¡cora]
1. Explica tu idea y realiza algunos bocetos.
2. Implementa tu idea.
3. Incluye todos los cÃ³digos (servidor y clientes) en tu bitÃ¡cora.
:::

## Evidencias ğŸ—‚ï¸

<Aside type="note" title="RUBRICA!">
* Recuerda que la bitÃ¡cora se cierra 10 minutos antes de la segunda sesiÃ³n de la semana 2 de la unidad. 
* Si no realizas la autoevaluaciÃ³n tu nota serÃ¡ 0.
* Si una actividad no estÃ¡ COMPLETA debes multiplicar la nota de esa actividad por el porcentaje 
de avance que tengas.

**RÃºbrica de evaluaciÃ³n del proceso**

5: realicÃ© las 5 actividades completas y la autoevaluaciÃ³n.  
3: realicÃ© 4 actividades completas y la autoevaluaciÃ³n.  
2: realicÃ© 3 actividades completas y la autoevaluaciÃ³n.  
1: realicÃ© 2 actividades completas y la autoevaluaciÃ³n.  
0.5: realicÃ© 1 actividad completa y la autoevaluaciÃ³n.  
0: no realicÃ© ninguna actividad o no realicÃ© la autoevaluaciÃ³n.  
</Aside>

<Aside type="danger" title="EVIDENCIAS EN BITÃCORA">

1. Realiza las actividades propuestas en esta unidad y documenta todo el proceso en tu bitÃ¡cora.  
2. Realiza la autoevaluaciÃ³n indicando:
    * Tu nota propuesta.
    * La defensa de esa nota para cada actividad. 
</Aside>



## Reflect: ConsolidaciÃ³n y metacogniciÃ³n ğŸ¤”

Para esta fase de pedirÃ© que hagas un diagrama que explique cÃ³mo funciona tu aplicaciÃ³n y 
cÃ³mo se comunican los diferentes componentes.
