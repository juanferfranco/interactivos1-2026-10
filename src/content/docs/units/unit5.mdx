---
title: Unidad 5
unitId: unit5
---

import { Aside } from '@astrojs/starlight/components';

## Introducci칩n 游닆

En esta unidad vas a explorar un nuevo tipo de protocolo de comunicaci칩n serial, el protocolo binario. Este 
protocolo es m치s eficiente que el ASCII, ya que permite enviar mas informaci칩n en menos tiempo. Sin embargo, es m치s 
complejo de implementar y requiere un mayor conocimiento de la programaci칩n de bajo nivel. Por tanto, te voy a 
proponer que continuemos con la misma aplicaci칩n que exploramos en la unidad anterior, pero ahora la vamos a 
modificar para que use el protocolo binario. De esta manera podr치s comparar los dos protocolos y ver 
las ventajas y desventajas de cada uno.

## Set: 쯈u칠 aprender치s en esta unidad? 游눠

Vas a enviar informaci칩n desde el micro:bit a un sketch en p5.js usando protocolos de comunicaci칩n binarios. 
Adem치s, vas a comparar los protocolos ASCII y binario y ver치s las ventajas y desventajas de cada uno.


## R칰brica de evaluaci칩n de la unidad 游닇

Esta r칰brica eval칰a tu proceso en toda la unidad desde la actividad 1 hasta la actividad 4. La 
actividad 5 es una actividad de autoevaluaci칩n y no se eval칰a de manera sumativa.

<Aside type="note" title="RUBRICA!">

Esta r칰brica est치 dise침ada para evaluar tu proceso de exploraci칩n, experimentaci칩n y aprendizaje al trabajar con protocolos de 
comunicaci칩n binarios, tal como se documenta en tu bit치cora de aprendizaje, abarcando desde la Actividad 01 hasta la Actividad 04. 
El foco no est치 en el resultado final perfecto de la aplicaci칩n, sino en la profundidad de tu investigaci칩n, la calidad de tus 
experimentos para entender los mecanismos subyacentes y tu capacidad para reflexionar y articular lo que has aprendido.

| Criterio | **Inicial (0.0 - 1.9)** | **En desarrollo (2.0 - 3.4)** | **Logrado (3.5 - 4.4)** | **Excelente (4.5 - 5.0)** |
| :--- | :--- | :--- | :--- | :--- |
| **1. Profundidad de la Indagaci칩n** | Las preguntas formuladas (o la falta de ellas) son superficiales y la exploraci칩n se limita a seguir las instrucciones sin cuestionar el "porqu칠" de las soluciones. | Se formulan preguntas relevantes, pero se enfocan principalmente en el "c칩mo" funcionan las partes del c칩digo (ej. "쮺칩mo usar `struct.pack`?"). La indagaci칩n se centra en resolver problemas t칠cnicos inmediatos. | Se formulan preguntas que **comparan y contrastan** los protocolos (ej. "쮺u치ntos bytes ahorro realmente con el protocolo binario en mi caso espec칤fico?"). Se investiga la causa ra칤z de los errores (ej. "쯇or qu칠 ocurre el error de sincronizaci칩n?"). | Se formulan preguntas que exploran el **dise침o y sus implicaciones** (ej. "쯈u칠 otras estrategias de *framing* existen y cu치les son sus ventajas?" o "쮼n qu칠 escenarios un protocolo ASCII podr칤a ser preferible a uno binario, a pesar de su ineficiencia?"). La indagaci칩n demuestra una curiosidad por los principios de la comunicaci칩n de datos. |
| **2. Calidad de la Experimentaci칩n** | Los experimentos se limitan a la simple ejecuci칩n del c칩digo proporcionado o de las modificaciones indicadas, sin un an치lisis sistem치tico. | Se realizan los experimentos guiados y se utiliza la terminal serial o la consola de p5.js para observar los datos, pero sin un an치lisis profundo de lo observado. | Se dise침an y ejecutan experimentos **deliberados y efectivos** para verificar hip칩tesis o el funcionamiento de componentes espec칤ficos (ej. enviar valores conocidos para validar la lectura, provocar un error de *checksum* para verificar su manejo). | Se dise침an experimentos **precisos y creativos** que no solo verifican, sino que **a칤slan y demuestran** la necesidad de ciertas soluciones o las sutilezas de la comunicaci칩n. Por ejemplo, se dise침a un caso de prueba para reproducir de forma consistente el error de sincronizaci칩n *antes* de implementar la soluci칩n de *framing*. |
| **3. An치lisis y Reflexi칩n** | La bit치cora es un registro de acciones sin an치lisis. Se describe lo que se ve (ej. "salen caracteres raros en la terminal") pero no se explica la causa. Las conclusiones son incorrectas o no est치n respaldadas por evidencia. | La bit치cora describe los resultados, pero la reflexi칩n es superficial. Se identifica el problema (ej. "los datos llegan mal") pero no se articula claramente por qu칠 una soluci칩n (como el *framing*) lo resuelve a nivel de bytes. | La bit치cora **conecta claramente la evidencia** (capturas de la terminal, logs de la consola, depurador) con la explicaci칩n te칩rica. Se analiza por qu칠 un protocolo sin *framing* es fr치gil y c칩mo la combinaci칩n de *header* y *checksum* aporta robustez. Se analizan los errores como parte del aprendizaje. | La bit치cora demuestra una **reflexi칩n profunda** que va m치s all치 de la simple verificaci칩n. Se analiza el *trade-off* entre eficiencia de transmisi칩n y complejidad de implementaci칩n, y se construye un **modelo mental robusto** del flujo de datos, desde el microcontrolador hasta la aplicaci칩n de p5.js. |
| **4. Apropiaci칩n y Articulaci칩n de Conceptos** | La bit치cora muestra una definici칩n incorrecta o copiada de los conceptos (ej. *framing*, *checksum*, *DataView*). No hay evidencia de comprensi칩n personal. | La bit치cora explica los conceptos de forma b치sica. Se entiende que el protocolo binario "es m치s r치pido", pero no se puede explicar por qu칠 en t칠rminos de representaci칩n de datos o flujo de bytes. | La bit치cora demuestra una **comprensi칩n clara y correcta** de cada componente del protocolo. Se explica con palabras propias la funci칩n del *header*, del *checksum*, del `DataView` en JavaScript y del empaquetado con `struct` en MicroPython. | La bit치cora demuestra una **maestr칤a conceptual**. Se explican los conceptos como un **sistema interdependiente**. Se articula con total claridad y usando analog칤as propias por qu칠 la comunicaci칩n serial es un flujo de bytes as칤ncrono y c칩mo un protocolo impone orden sobre ese "caos" para garantizar una comunicaci칩n fiable y eficiente. |

</Aside>

<Aside type="caution" title="Valoraci칩n de la unidad">

1. En la bit치cora vas proponer una nota o valoraci칩n para esta unidad seg칰n la r칰brica. 
Adem치s, deber치s justificar tu valoraci칩n para cada criterio de la r칰brica, se침alando claramente 
las evidencias que has aportado en tu bit치cora.

En la 칰ltima sesi칩n de la semana 2 de la unidad realizar치s la evaluaci칩n sumativa con el 
profesor mediante una una conversaci칩n corta de m치ximo 4 minutos.

2. Si no tienes realizado el ejercicio de valoraci칩n de la unidad, no podr치s 
tener la conversaci칩n con el profesor y por tanto tu nota temporal ser치 0. En ese 
caso habla con el profesor para acordar el plan de acci칩n a seguir.

</Aside>

### Actividad 01

#### Repasa el caso de estudio 

En esta actividad vas a poner a funcionar el caso de estudio de la unidad anterior y 
lo vas a repasar de nuevo. Mira, es muy importante que le dedique un tiempo generoso a revisar de nuevo 
el caso de estudio, ya que es un ejemplo muy completo y te va a ayudar a entender mejor el resto de la unidad.

El [c칩digo del micro:bit](https://python.microbit.org/v/3) es este:

``` py
# Imports go at the top
from microbit import *

uart.init(115200)
display.set_pixel(0,0,9)

while True:
    xValue = accelerometer.get_x()
    yValue = accelerometer.get_y()
    aState = button_a.is_pressed()
    bState = button_b.is_pressed()
    data = "{},{},{},{}\n".format(xValue, yValue, aState,bState)
    uart.write(data)
    sleep(100) # Envia datos a 10 Hz
```

El c칩digo del [sketch](https://editor.p5js.org/) es este:

**index.html**:

``` js
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.10/lib/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5.sound@0.2.0/dist/p5.sound.min.js"></script>
    <script src="https://unpkg.com/@gohai/p5.webserial@^1/libraries/p5.webserial.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <script src="sketch.js"></script>
  </body>
</html>
```

Carga las im치genes:

![p5.js files](../../../assets/unit4-files.png)

**sketch.js**:

``` js
let c;
let lineModuleSize = 0;
let angle = 0;
let angleSpeed = 1;
const lineModule = [];
let lineModuleIndex = 0;
let clickPosX = 0;
let clickPosY = 0;

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let connectionInitialized = false;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;
let microBitX = 0;
let microBitY = 0;
let microBitAState = false;
let microBitBState = false;
let prevmicroBitAState = false;
let prevmicroBitBState = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);

  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
    connectionInitialized = false;
  } else {
    port.close();
  }
}

function updateButtonStates(newAState, newBState) {
  // Generar eventos de keypressed
  if (newAState === true && prevmicroBitAState === false) {
    // create a new random color and line length
    lineModuleSize = random(50, 160);
    // remember click position
    clickPosX = microBitX;
    clickPosY = microBitY;
    print("A pressed");
  }
  // Generar eventos de key released
  if (newBState === false && prevmicroBitBState === true) {
    c = color(random(255), random(255), random(255), random(80, 100));
    print("B released");
  }

  prevmicroBitAState = newAState;
  prevmicroBitBState = newBState;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  //******************************************
  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
    microBitConnected = false;
  } else {
    microBitConnected = true;
    connectBtn.html("Disconnect");

    if (port.opened() && !connectionInitialized) {
      port.clear();
      connectionInitialized = true;
    }

    if (port.availableBytes() > 0) {
      let data = port.readUntil("\n");
      if (data) {
        data = data.trim();
        let values = data.split(",");
        if (values.length == 4) {
          microBitX = int(values[0]) + windowWidth / 2;
          microBitY = int(values[1]) + windowHeight / 2;
          microBitAState = values[2].toLowerCase() === "true";
          microBitBState = values[3].toLowerCase() === "true";
          updateButtonStates(microBitAState, microBitBState);
        } else {
          print("No se est치n recibiendo 4 datos del micro:bit");
        }
      }
    }
  }
  //*******************************************

  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      // No puede comenzar a dibujar hasta que no se conecte el microbit
      // evento 1:
      if (microBitConnected === true) {
        // Preparo todo para el estado en el pr칩ximo frame
        print("Microbit ready to draw");
        strokeWeight(0.75);
        c = color(181, 157, 0);
        noCursor();
        appState = STATES.RUNNING;
      }

      break;

    case STATES.RUNNING:
      // EVENTO: estado de conexi칩n del microbit
      if (microBitConnected === false) {
        print("Waiting microbit connection");
        cursor();
        appState = STATES.WAIT_MICROBIT_CONNECTION;
      }

      //EVENTO: recepci칩n de datos seriales del micro:bit

      if (microBitAState === true) {
        let x = microBitX;
        let y = microBitY;

        if (keyIsPressed && keyCode === SHIFT) {
          if (abs(clickPosX - x) > abs(clickPosY - y)) {
            y = clickPosY;
          } else {
            x = clickPosX;
          }
        }

        push();
        translate(x, y);
        rotate(radians(angle));
        if (lineModuleIndex != 0) {
          tint(c);
          image(
            lineModule[lineModuleIndex],
            0,
            0,
            lineModuleSize,
            lineModuleSize
          );
        } else {
          stroke(c);
          line(0, 0, lineModuleSize, lineModuleSize);
        }
        angle += angleSpeed;
        pop();
      }

      break;
  }
}

function keyPressed() {
  if (keyCode == UP_ARROW) lineModuleSize += 5;
  if (keyCode == DOWN_ARROW) lineModuleSize -= 5;
  if (keyCode == LEFT_ARROW) angleSpeed -= 0.5;
  if (keyCode == RIGHT_ARROW) angleSpeed += 0.5;
}

function keyReleased() {
  if (key == "s" || key == "S") {
    let ts =
      year() +
      nf(month(), 2) +
      nf(day(), 2) +
      "_" +
      nf(hour(), 2) +
      nf(minute(), 2) +
      nf(second(), 2);
    saveCanvas(ts, "png");
  }
  if (keyCode == DELETE || keyCode == BACKSPACE) background(255);

  // reverse direction and mirror angle
  if (key == "d" || key == "D") {
    angle += 180;
    angleSpeed *= -1;
  }

  // default colors from 1 to 4
  if (key == "1") c = color(181, 157, 0);
  if (key == "2") c = color(0, 130, 164);
  if (key == "3") c = color(87, 35, 129);
  if (key == "4") c = color(197, 0, 123);

  // load svg for line module
  if (key == "5") lineModuleIndex = 0;
  if (key == "6") lineModuleIndex = 1;
  if (key == "7") lineModuleIndex = 2;
  if (key == "8") lineModuleIndex = 3;
  if (key == "9") lineModuleIndex = 4;
}

```

En tu bit치cora de aprendizaje puedes abordar estas preguntas:

- Describe c칩mo se est치n comunicando el micro:bit y el sketch de p5.js. 
쯈u칠 datos env칤a el micro:bit?
- 쮺칩mo es la estructura del protocolo ASCII usado?
- Muestra y explica la parte del c칩digo de p5.js donde lee los datos del micro:bit y los 
transforma en coordenadas de la pantalla.
- 쮺칩mo se generan los eventos A pressed y B released que se generan en p5.js 
a partir de los datos que env칤a el micro:bit?
- Capturas de pantalla de los algunos dibujos que hayas hecho con el sketch.

## Seek: Investigaci칩n 游댍

En esta fase, vas a analizar un caso de estudio que te servir치 de base para resolver el 
problema que te plantear칠 luego. Sin embargo, esta vez iremos m치s r치pido, ya que el caso de 
estudio lo conoces de la unidad anterior. Nos concentraremos en la parte de la comunicaci칩n 
serial usando protocolos binarios.

### Actividad 02

#### Caso de estudio: micro:bit

Vamos a transformar el caso de estudio de la unidad anterior para que 
ahora la comunicaci칩n entre el micro:bit y p5.js se realice mediante 
un protocolo binario. Primero analizaremos el c칩digo del micro:bit y 
en la siguiente actividad veremos c칩mo leer los datos en p5.js.

Durante la lectura te indicar칠 los momentos en los que vale la pena detenerte 
para analizar 游븷, experimentar 游빍 y reportar 九꽲잺 tus hallazgos en la bit치cora de aprendizaje.


Vamos a transformar el c칩digo. Originalmente este era el c칩digo del micro:bit que enviaba 
datos en texto plano o ASCII:

``` py
# Imports go at the top
from microbit import *

uart.init(115200)
display.set_pixel(0,0,9)

while True:
    xValue = accelerometer.get_x()
    yValue = accelerometer.get_y()
    aState = button_a.is_pressed()
    bState = button_b.is_pressed()
    data = "{},{},{},{}\n".format(xValue, yValue, aState,bState)
    uart.write(data)
    sleep(100) # Envia datos a 10 Hz
```

Ahora vas a reemplazar la manera como empaquetar치s los datos para enviarlos 
por el puerto serial. Cambia esta l칤nea:

``` py
data = "{},{},{},{}\n".format(xValue, yValue, aState,bState)
```

Por esta:

``` py
data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
```
Para que la l칤nea anterior funcione deber치s importar el m칩dulo 
`struct` al inicio del c칩digo: 

``` py
# Imports go at the top
from microbit import *
import struct
```

El m칩dulo `struct` permite empaquetar los datos en un formato binario. En este caso,  
el formato `'>2h2B'` indica que se env칤an 2 enteros cortos (xValue, yValue) y 2 enteros  
sin signo (aState, bState). El s칤mbolo `>` indica que los datos se env칤an en orden de   
bytes grande (big-endian), lo que significa que el byte m치s significativo se env칤a primero.   
El formato `2h` indica que se env칤an 2 enteros cortos de 2 bytes cada uno (xValue, yValue),  
y `2B` indica que se env칤an 2 enteros sin signo de 1 byte cada uno (aState, bState).  
El resultado es que los datos se env칤an en un formato binario m치s compacto y eficiente  
que el formato de texto plano. Esto es especialmente 칰til cuando se env칤an grandes  
cantidades de datos o cuando se requiere un rendimiento 칩ptimo en la comunicaci칩n.  

El c칩digo completo quedar칤a as칤:

``` py
# Imports go at the top
from microbit import *
import struct
uart.init(115200)
display.set_pixel(0,0,9)

while True:
    xValue = accelerometer.get_x()
    yValue = accelerometer.get_y()
    aState = button_a.is_pressed()
    bState = button_b.is_pressed()
    data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
    uart.write(data)
    sleep(100) # Envia datos a 10 Hz
```

쯇ero c칩mo se ven esos datos binarios? Para averiguarlo, vas a usar la aplicaci칩n
[SerialTerminal](https://juanferfranco.github.io/serialTerminal/) que usaste en la unidad anterior.

Abre la aplicaci칩n, configura el puerto, deja los valores por defecto y presiona ``Conectar``. Selecciona 
el puerto del micro:bit (mbed Serial port) y presiona ``Conectar``. Luego, en la secci칩n de 
``Recepci칩n de Datos``, en ``Mostrar datos como``, selecciona ``Texto``.

游븷游빍九꽲잺 Captura el resultado del experimento anterior. 쯇or qu칠 se ve este resultado?

Ahora cambia la opci칩n de ``Mostrar datos como`` a ``Todo en Hex`` y vuelve a capturar el resultado.

游븷游빍九꽲잺 Captura el resultado del experimento anterior. Lo que ves 쮺칩mo est치 relacionado 
con esta l칤nea de c칩digo?

``` py
data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
```

No te parece que el resultado es un poco m치s dif칤cil de leer que el texto en ASCII?

游븷游빍九꽲잺 쯈u칠 ventajas y desventajas ves en usar un formato binario en lugar de texto en ASCII?

Ahora te voy a proponer un experimento que te permitir치 ver mejor los datos. Cambia 
el c칩digo del micro:bit por este: 

``` py
# Imports go at the top
from microbit import *
import struct
uart.init(115200)
display.set_pixel(0,0,9)

while True:
    if accelerometer.was_gesture('shake'):
        xValue = accelerometer.get_x()
        yValue = accelerometer.get_y()
        aState = button_a.is_pressed()
        bState = button_b.is_pressed()
        data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
        uart.write(data)
```

游븷游빍九꽲잺 Captura el resultado del experimento. 쮺u치ntos bytes se est치n enviando por 
mensaje? 쮺칩mo se relaciona esto con el formato `'>2h2B'`? 쯈u칠 significa cada uno de los bytes
que se env칤an?

游븷游빍九꽲잺 Recuerda de la unidad anterior que es posible enviar n칰meros positivos y negativos 
para los valores de xValue y yValue. 쮺칩mo se ver칤an esos n칰meros en el formato
`'>2h2B'`? 

Ahora realiza el siguiente experimento para comparar el env칤o de datos en ASCII y en binario.

``` py
# Imports go at the top
from microbit import *
import struct
uart.init(115200)
display.set_pixel(0,0,9)

while True:
    if accelerometer.was_gesture('shake'):
        xValue = accelerometer.get_x()
        yValue = accelerometer.get_y()
        aState = button_a.is_pressed()
        bState = button_b.is_pressed()
        data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
        uart.write(data)
        uart.write("ASCII:\n")
        data = "{},{},{},{}\n".format(xValue, yValue, aState,bState)
        uart.write(data)
```

游븷游빍九꽲잺 Captura el resultado del experimento. 쯈u칠 diferencias ves entre los datos 
en ASCII y en binario? 쯈u칠 ventajas y desventajas ves en usar un formato binario
en lugar de texto en ASCII? 쯈u칠 ventajas y desventajas ves en usar un formato
ASCII en lugar de binario?

### Actividad 03

#### Caso de estudio: p5.js

Ahora vamos a modificar el c칩digo de p5.js para soportar 
la lectura de datos en formato binario.

Te voy a proponer que temporalmente env칤es los mismos datos desde el micro:bit. La 
idea es que puedas saber exactamente qu칠 datos est치s enviando y de esta manera 
verificar que el c칩digo de p5.js est치 funcionando correctamente.

Para esto, cambia el c칩digo del micro:bit por este:

``` py
# Imports go at the top
from microbit import *
import struct
uart.init(115200)
display.set_pixel(0,0,9)

while True:
    """
    xValue = accelerometer.get_x()
    yValue = accelerometer.get_y()
    aState = button_a.is_pressed()
    bState = button_b.is_pressed()
    """
    xValue = 500
    yValue = 524
    aState = True
    bState = False
    data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
    uart.write(data)
    sleep(100) # Envia datos a 10 Hz
```

Te recuerdo: si los valores de xValue y yValue son enteros cortos de 2 bytes,
aState y bState son enteros sin signo de 1 byte, entonces el tama침o total del paquete
es de 2 + 2 + 1 + 1 = 6 bytes. Por ejemplo, en este caso:

``` py
xValue = 500
yValue = 524
aState = True
bState = False
```
El paquete que se enviar칤a ser칤a:

``` py
01 f4 02 0c 01 00
```

Los primeros dos bytes son el valor de xValue (500) en big-endian y en hexadecimal
(01 f4), los siguientes dos bytes son el valor de yValue (524) en big-endian y en
hexadecimal (02 0c), y los 칰ltimos dos bytes son el valor de aState (True) y bState (False)
en hexadecimal (01 00).

En la unidad anterior era necesario separar los valores y marcar el fin del paquete
con un salto de l칤nea. Ahora no es necesario, ya que el tama침o del paquete es fijo
y no se necesita un delimitador. En este caso, el paquete es de 6 bytes y no se 
necesita un salto de l칤nea para indicar el final del paquete. 

游븷游빍九꽲잺 Explica por qu칠 en la unidad anterior ten칤amos que enviar la informaci칩n 
delimitada y adem치s marcada con un salto de l칤nea y ahora no es necesario.

Con lo anterior en mente, ahora vas a modificar el c칩digo de p5.js para leer 
los datos en formato binario. Sin embargo, al igual que con el c칩digo del micro:bit, 
te pedir칠 que primero verifiquemos si los datos se est치n enviando correctamente.

Cambia el c칩digo de p5.js para que se vea as칤:

``` js
let c;
let lineModuleSize = 0;
let angle = 0;
let angleSpeed = 1;
const lineModule = [];
let lineModuleIndex = 0;
let clickPosX = 0;
let clickPosY = 0;

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;
let microBitX = 0;
let microBitY = 0;
let microBitAState = false;
let microBitBState = false;
let prevmicroBitAState = false;
let prevmicroBitBState = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);

  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
  } else {
    port.close();
  }
}

function updateButtonStates(newAState, newBState) {
  // Generar eventos de keypressed
  if (newAState === true && prevmicroBitAState === false) {
    // create a new random color and line length
    lineModuleSize = random(50, 160);
    // remember click position
    clickPosX = microBitX;
    clickPosY = microBitY;
    print("A pressed");
  }
  // Generar eventos de key released
  if (newBState === false && prevmicroBitBState === true) {
    c = color(random(255), random(255), random(255), random(80, 100));
    print("B released");
  }

  prevmicroBitAState = newAState;
  prevmicroBitBState = newBState;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  //******************************************
  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
    microBitConnected = false;
  } else {
    microBitConnected = true;
    connectBtn.html("Disconnect");

    if (port.availableBytes() >= 6) {
      let data = port.readBytes(6);
      if (data) {
        const buffer = new Uint8Array(data).buffer;
        const view = new DataView(buffer);
        microBitX = view.getInt16(0);
        microBitY = view.getInt16(2);
        microBitAState = view.getUint8(4) === 1;
        microBitBState = view.getUint8(5) === 1;
        updateButtonStates(microBitAState, microBitBState);
        
        print(`microBitX: ${microBitX} microBitY: ${microBitY} microBitAState: ${microBitAState} microBitBState: ${microBitBState} \n` );
        
        /*
        microBitX = int(values[0]) + windowWidth / 2;
        microBitY = int(values[1]) + windowHeight / 2;
        microBitAState = values[2].toLowerCase() === "true";
        microBitBState = values[3].toLowerCase() === "true";
              
        updateButtonStates(microBitAState, microBitBState);
        */
        
      }
    }
  }
  //*******************************************

  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      // No puede comenzar a dibujar hasta que no se conecte el microbit
      // evento 1:
      if (microBitConnected === true) {
        // Preparo todo para el estado en el pr칩ximo frame
        print("Microbit ready to draw");
        strokeWeight(0.75);
        c = color(181, 157, 0);
        noCursor();
        appState = STATES.RUNNING;
      }

      break;

    case STATES.RUNNING:
      // EVENTO: estado de conexi칩n del microbit
      if (microBitConnected === false) {
        print("Waiting microbit connection");
        cursor();
        appState = STATES.WAIT_MICROBIT_CONNECTION;
      }

      //EVENTO: recepci칩n de datos seriales del micro:bit

      if (microBitAState === true) {
        let x = microBitX;
        let y = microBitY;

        if (keyIsPressed && keyCode === SHIFT) {
          if (abs(clickPosX - x) > abs(clickPosY - y)) {
            y = clickPosY;
          } else {
            x = clickPosX;
          }
        }

        push();
        translate(x, y);
        rotate(radians(angle));
        if (lineModuleIndex != 0) {
          tint(c);
          image(
            lineModule[lineModuleIndex],
            0,
            0,
            lineModuleSize,
            lineModuleSize
          );
        } else {
          stroke(c);
          line(0, 0, lineModuleSize, lineModuleSize);
        }
        angle += angleSpeed;
        pop();
      }

      break;
  }
}

function keyPressed() {
  if (keyCode === UP_ARROW) lineModuleSize += 5;
  if (keyCode === DOWN_ARROW) lineModuleSize -= 5;
  if (keyCode === LEFT_ARROW) angleSpeed -= 0.5;
  if (keyCode === RIGHT_ARROW) angleSpeed += 0.5;
}

function keyReleased() {
  if (key === "s" || key === "S") {
    let ts =
      year() +
      nf(month(), 2) +
      nf(day(), 2) +
      "_" +
      nf(hour(), 2) +
      nf(minute(), 2) +
      nf(second(), 2);
    saveCanvas(ts, "png");
  }
  if (keyCode === DELETE || keyCode === BACKSPACE) background(255);

  // reverse direction and mirror angle
  if (key === "d" || key === "D") {
    angle += 180;
    angleSpeed *= -1;
  }

  // default colors from 1 to 4
  if (key === "1") c = color(181, 157, 0);
  if (key === "2") c = color(0, 130, 164);
  if (key === "3") c = color(87, 35, 129);
  if (key === "4") c = color(197, 0, 123);

  // load svg for line module
  if (key === "5") lineModuleIndex = 0;
  if (key === "6") lineModuleIndex = 1;
  if (key === "7") lineModuleIndex = 2;
  if (key === "8") lineModuleIndex = 3;
  if (key === "9") lineModuleIndex = 4;
}
```

Casi todo el c칩digo es el mismo que en la unidad anterior, pero esta 
vez nos vamos a concentrar solo en esta parte:

``` js
if (port.availableBytes() >= 6) {
    let data = port.readBytes(6);
    if (data) {
    const buffer = new Uint8Array(data).buffer;
    const view = new DataView(buffer);
    microBitX = view.getInt16(0);
    microBitY = view.getInt16(2);
    microBitAState = view.getUint8(4) === 1;
    microBitBState = view.getUint8(5) === 1;
    updateButtonStates(microBitAState, microBitBState);
    
    print(`microBitX: ${microBitX} microBitY: ${microBitY} microBitAState: ${microBitAState} microBitBState: ${microBitBState} \n` );
    
    /*
    microBitX = int(values[0]) + windowWidth / 2;
    microBitY = int(values[1]) + windowHeight / 2;
    microBitAState = values[2].toLowerCase() === "true";
    microBitBState = values[3].toLowerCase() === "true";
    updateButtonStates(microBitAState, microBitBState);
    */
    
    }
}
```

游븷游빍九꽲잺 Compara el c칩digo de la unidad anterior relacionado con la recepci칩n 
de los datos seriales que ves ahora. 쯈u칠 cambios observas?

Ahora te voy a pedir que ejecutes el c칩digo de p5.js muchas veces y que 
est칠s muy atento a la consola. Lo que haremos es a tratar de reproducir un error 
que tiene este c칩digo. El error es de sincronizaci칩n y se produce cuando 
los 6 bytes que lee el c칩digo de p5.js no corresponden a los mismos 6 bytes 
que env칤a el micro:bit. 

Te voy mostrar por ejemplo un resultado que obtuve al ejecutar el c칩digo 
de p5.js:

``` js

Connected to serial port 
A pressed 
microBitX: 500 microBitY: 524 microBitAState: true microBitBState: false 

Microbit ready to draw 
92 microBitX: 500 microBitY: 524 microBitAState: true microBitBState: false 
 
microBitX: 500 microBitY: 513 microBitAState: false microBitBState: false 
 
222 microBitX: 3073 microBitY: 1 microBitAState: false microBitBState: false 
```

游븷游빍九꽲잺 쯈u칠 ves en la consola? 쯇or qu칠 crees que se produce este error? 

Para solucionar este tipo de problemas, es usual que los comunicaciones seriales 
implementen una estrategia de sincronizaci칩n. La estrategia que vamos a usar 
se denomina ``framing`` y consiste en enviar un byte de inicio y un byte de fin 
del paquete. 

**쯇or qu칠 necesitamos framing?**

Cuando se env칤an datos a trav칠s de una comunicaci칩n serial, los bytes pueden llegar en fragmentos 
arbitrarios y sin respetar los l칤mites de los paquetes. Esto significa que, sin un 
mecanismo que delimite el inicio y el fin de cada paquete, el receptor puede comenzar 
a leer a mitad de un paquete o mezclar bytes de dos paquetes consecutivos. Este 
desalineamiento puede producir interpretaciones err칩neas (por ejemplo, obtener valores 
como ``microBitY: 513`` en lugar de 524) y dificultar la detecci칩n de errores. Con el 
framing se asegura que:

- Sincronizaci칩n: el receptor identifica claramente d칩nde comienza un paquete 
(por ejemplo, usando un byte espec칤fico como header o byte inicial).

- Integridad: se puede incluir un checksum o CRC para verificar que los datos 
recibidos sean correctos.

- Robustez: incluso si la comunicaci칩n se fragmenta o se reciben datos residuales, 
el receptor puede descartar bytes hasta encontrar un paquete completo y correcto.

Para implementar esta estrategia ser치 necesario modificar el c칩digo 
del micro:bit y el c칩digo de p5.js.

En e caso del micro:bit se enviar치 un paquete de 8 bytes:

```
Byte 0: Header (0xAA)
Bytes 1-6: Datos (dos enteros de 16 bits y dos bytes para estados)
Byte 7: Checksum (suma de los 6 bytes de datos m칩dulo 256)
```

De nuevo, el c칩digo del micro:bit quedar칤a as칤:

``` py
from microbit import *
import struct

uart.init(115200)
display.set_pixel(0, 0, 9)

while True:
    xValue = 500
    yValue = 524
    aState = True
    bState = False
    # Empaqueta los datos: 2 enteros (16 bits) y 2 bytes para estados
    data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
    # Calcula un checksum simple: suma de los bytes de data m칩dulo 256
    checksum = sum(data) % 256
    # Crea el paquete con header, datos y checksum
    packet = b'\xAA' + data + bytes([checksum])
    uart.write(packet)
    sleep(100)  # Env칤a datos a 10 Hz
```

Ahora, el c칩digo de p5.js quedar칤a as칤:

``` js
let serialBuffer = []; // Buffer para almacenar bytes recibidos

let c;
let lineModuleSize = 0;
let angle = 0;
let angleSpeed = 1;
const lineModule = [];
let lineModuleIndex = 0;
let clickPosX = 0;
let clickPosY = 0;

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;
let microBitX = 0;
let microBitY = 0;
let microBitAState = false;
let microBitBState = false;
let prevmicroBitAState = false;
let prevmicroBitBState = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);

  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
  } else {
    port.close();
  }
}

function updateButtonStates(newAState, newBState) {
  // Generar eventos de keypressed
  if (newAState === true && prevmicroBitAState === false) {
    // create a new random color and line length
    lineModuleSize = random(50, 160);
    // remember click position
    clickPosX = microBitX;
    clickPosY = microBitY;
    print("A pressed");
  }
  // Generar eventos de key released
  if (newBState === false && prevmicroBitBState === true) {
    c = color(random(255), random(255), random(255), random(80, 100));
    print("B released");
  }

  prevmicroBitAState = newAState;
  prevmicroBitBState = newBState;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function readSerialData() {
  // Acumula los bytes recibidos en el buffer
  let available = port.availableBytes();
  if (available > 0) {
    let newData = port.readBytes(available);
    serialBuffer = serialBuffer.concat(newData);
  }

  // Procesa el buffer mientras tenga al menos 8 bytes (tama침o de un paquete)
  while (serialBuffer.length >= 8) {
    // Busca el header (0xAA)
    if (serialBuffer[0] !== 0xaa) {
      serialBuffer.shift(); // Descarta bytes hasta encontrar el header
      continue;
    }

    // Si hay menos de 8 bytes, espera a que llegue el paquete completo
    if (serialBuffer.length < 8) break;

    // Extrae los 8 bytes del paquete
    let packet = serialBuffer.slice(0, 8);
    serialBuffer.splice(0, 8); // Elimina el paquete procesado del buffer

    // Separa datos y checksum
    let dataBytes = packet.slice(1, 7);
    let receivedChecksum = packet[7];
    // Calcula el checksum sumando los datos y aplicando m칩dulo 256
    let computedChecksum = dataBytes.reduce((acc, val) => acc + val, 0) % 256;

    if (computedChecksum !== receivedChecksum) {
      console.log("Checksum error in packet");
      continue; // Descarta el paquete si el checksum no es v치lido
    }

    // Si el paquete es v치lido, extrae los valores
    let buffer = new Uint8Array(dataBytes).buffer;
    let view = new DataView(buffer);
    microBitX = view.getInt16(0);
    microBitY = view.getInt16(2);
    microBitAState = view.getUint8(4) === 1;
    microBitBState = view.getUint8(5) === 1;
    updateButtonStates(microBitAState, microBitBState);

    console.log(
      `microBitX: ${microBitX} microBitY: ${microBitY} microBitAState: ${microBitAState} microBitBState: ${microBitBState}`
    );
  }
}

function draw() {
  //******************************************
  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
    microBitConnected = false;
  } else {
    microBitConnected = true;
    connectBtn.html("Disconnect");
  }

  //*******************************************

  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      // No puede comenzar a dibujar hasta que no se conecte el microbit
      // evento 1:
      if (microBitConnected === true) {
        // Preparo todo para el estado en el pr칩ximo frame
        print("Microbit ready to draw");
        strokeWeight(0.75);
        c = color(181, 157, 0);
        noCursor();
        port.clear();
        prevmicroBitAState = false;
        prevmicroBitBState = false;
        appState = STATES.RUNNING;
      }

      break;

    case STATES.RUNNING:
      // EVENTO: estado de conexi칩n del microbit
      if (microBitConnected === false) {
        print("Waiting microbit connection");
        cursor();
        appState = STATES.WAIT_MICROBIT_CONNECTION;
        break;
      }

      //EVENTO: recepci칩n de datos seriales del micro:bit

      readSerialData();

      if (microBitAState === true) {
        let x = microBitX;
        let y = microBitY;

        if (keyIsPressed && keyCode === SHIFT) {
          if (abs(clickPosX - x) > abs(clickPosY - y)) {
            y = clickPosY;
          } else {
            x = clickPosX;
          }
        }

        push();
        translate(x, y);
        rotate(radians(angle));
        if (lineModuleIndex != 0) {
          tint(c);
          image(
            lineModule[lineModuleIndex],
            0,
            0,
            lineModuleSize,
            lineModuleSize
          );
        } else {
          stroke(c);
          line(0, 0, lineModuleSize, lineModuleSize);
        }
        angle += angleSpeed;
        pop();
      }

      break;
  }
}

function keyPressed() {
  if (keyCode === UP_ARROW) lineModuleSize += 5;
  if (keyCode === DOWN_ARROW) lineModuleSize -= 5;
  if (keyCode === LEFT_ARROW) angleSpeed -= 0.5;
  if (keyCode === RIGHT_ARROW) angleSpeed += 0.5;
}

function keyReleased() {
  if (key === "s" || key === "S") {
    let ts =
      year() +
      nf(month(), 2) +
      nf(day(), 2) +
      "_" +
      nf(hour(), 2) +
      nf(minute(), 2) +
      nf(second(), 2);
    saveCanvas(ts, "png");
  }
  if (keyCode === DELETE || keyCode === BACKSPACE) background(255);

  // reverse direction and mirror angle
  if (key === "d" || key === "D") {
    angle += 180;
    angleSpeed *= -1;
  }

  // default colors from 1 to 4
  if (key === "1") c = color(181, 157, 0);
  if (key === "2") c = color(0, 130, 164);
  if (key === "3") c = color(87, 35, 129);
  if (key === "4") c = color(197, 0, 123);

  // load svg for line module
  if (key === "5") lineModuleIndex = 0;
  if (key === "6") lineModuleIndex = 1;
  if (key === "7") lineModuleIndex = 2;
  if (key === "8") lineModuleIndex = 3;
  if (key === "9") lineModuleIndex = 4;
}

```

游븷游빍九꽲잺 Analiza el c칩digo, observa los cambios. Ejecuta y luego observa 
la consola. 쯈u칠 ves?

La versi칩n final de los programas de micro:bit y p5.js
son las siguientes:

``` py
from microbit import *
import struct

uart.init(115200)
display.set_pixel(0, 0, 9)

while True:
    xValue = accelerometer.get_x()
    yValue = accelerometer.get_y()
    aState = button_a.is_pressed()
    bState = button_b.is_pressed()
    # Empaqueta los datos: 2 enteros (16 bits) y 2 bytes para estados
    data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
    # Calcula un checksum simple: suma de los bytes de data m칩dulo 256
    checksum = sum(data) % 256
    # Crea el paquete con header, datos y checksum
    packet = b'\xAA' + data + bytes([checksum])
    uart.write(packet)
    sleep(100)  # Env칤a datos a 10 Hz
```

``` js
let serialBuffer = []; // Buffer para almacenar bytes recibidos

let c;
let lineModuleSize = 0;
let angle = 0;
let angleSpeed = 1;
const lineModule = [];
let lineModuleIndex = 0;
let clickPosX = 0;
let clickPosY = 0;

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;
let microBitX = 0;
let microBitY = 0;
let microBitAState = false;
let microBitBState = false;
let prevmicroBitAState = false;
let prevmicroBitBState = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);

  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
  } else {
    port.close();
  }
}

function updateButtonStates(newAState, newBState) {
  // Generar eventos de keypressed
  if (newAState === true && prevmicroBitAState === false) {
    // create a new random color and line length
    lineModuleSize = random(50, 160);
    // remember click position
    clickPosX = microBitX;
    clickPosY = microBitY;
    print("A pressed");
  }
  // Generar eventos de key released
  if (newBState === false && prevmicroBitBState === true) {
    c = color(random(255), random(255), random(255), random(80, 100));
    print("B released");
  }

  prevmicroBitAState = newAState;
  prevmicroBitBState = newBState;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function readSerialData() {
  // Acumula los bytes recibidos en el buffer
  let available = port.availableBytes();
  if (available > 0) {
    let newData = port.readBytes(available);
    serialBuffer = serialBuffer.concat(newData);
  }

  // Procesa el buffer mientras tenga al menos 8 bytes (tama침o de un paquete)
  while (serialBuffer.length >= 8) {
    // Busca el header (0xAA)
    if (serialBuffer[0] !== 0xaa) {
      serialBuffer.shift(); // Descarta bytes hasta encontrar el header
      continue;
    }

    // Si hay menos de 8 bytes, espera a que llegue el paquete completo
    if (serialBuffer.length < 8) break;

    // Extrae los 8 bytes del paquete
    let packet = serialBuffer.slice(0, 8);
    serialBuffer.splice(0, 8); // Elimina el paquete procesado del buffer

    // Separa datos y checksum
    let dataBytes = packet.slice(1, 7);
    let receivedChecksum = packet[7];
    // Calcula el checksum sumando los datos y aplicando m칩dulo 256
    let computedChecksum = dataBytes.reduce((acc, val) => acc + val, 0) % 256;

    if (computedChecksum !== receivedChecksum) {
      console.log("Checksum error in packet");
      continue; // Descarta el paquete si el checksum no es v치lido
    }

    // Si el paquete es v치lido, extrae los valores
    let buffer = new Uint8Array(dataBytes).buffer;
    let view = new DataView(buffer);
    microBitX = view.getInt16(0) + windowWidth / 2;
    microBitY = view.getInt16(2) + windowHeight / 2;
    microBitAState = view.getUint8(4) === 1;
    microBitBState = view.getUint8(5) === 1;
    updateButtonStates(microBitAState, microBitBState);

  }
}

function draw() {
  //******************************************
  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
    microBitConnected = false;
  } else {
    microBitConnected = true;
    connectBtn.html("Disconnect");
  }

  //*******************************************

  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      // No puede comenzar a dibujar hasta que no se conecte el microbit
      // evento 1:
      if (microBitConnected === true) {
        // Preparo todo para el estado en el pr칩ximo frame
        print("Microbit ready to draw");
        strokeWeight(0.75);
        c = color(181, 157, 0);
        noCursor();
        port.clear();
        prevmicroBitAState = false;
        prevmicroBitBState = false;
        appState = STATES.RUNNING;
      }

      break;

    case STATES.RUNNING:
      // EVENTO: estado de conexi칩n del microbit
      if (microBitConnected === false) {
        print("Waiting microbit connection");
        cursor();
        appState = STATES.WAIT_MICROBIT_CONNECTION;
        break;
      }

      //EVENTO: recepci칩n de datos seriales del micro:bit

      readSerialData();

      if (microBitAState === true) {
        let x = microBitX;
        let y = microBitY;

        if (keyIsPressed && keyCode === SHIFT) {
          if (abs(clickPosX - x) > abs(clickPosY - y)) {
            y = clickPosY;
          } else {
            x = clickPosX;
          }
        }

        push();
        translate(x, y);
        rotate(radians(angle));
        if (lineModuleIndex != 0) {
          tint(c);
          image(
            lineModule[lineModuleIndex],
            0,
            0,
            lineModuleSize,
            lineModuleSize
          );
        } else {
          stroke(c);
          line(0, 0, lineModuleSize, lineModuleSize);
        }
        angle += angleSpeed;
        pop();
      }

      break;
  }
}

function keyPressed() {
  if (keyCode === UP_ARROW) lineModuleSize += 5;
  if (keyCode === DOWN_ARROW) lineModuleSize -= 5;
  if (keyCode === LEFT_ARROW) angleSpeed -= 0.5;
  if (keyCode === RIGHT_ARROW) angleSpeed += 0.5;
}

function keyReleased() {
  if (key === "s" || key === "S") {
    let ts =
      year() +
      nf(month(), 2) +
      nf(day(), 2) +
      "_" +
      nf(hour(), 2) +
      nf(minute(), 2) +
      nf(second(), 2);
    saveCanvas(ts, "png");
  }
  if (keyCode === DELETE || keyCode === BACKSPACE) background(255);

  // reverse direction and mirror angle
  if (key === "d" || key === "D") {
    angle += 180;
    angleSpeed *= -1;
  }

  // default colors from 1 to 4
  if (key === "1") c = color(181, 157, 0);
  if (key === "2") c = color(0, 130, 164);
  if (key === "3") c = color(87, 35, 129);
  if (key === "4") c = color(197, 0, 123);

  // load svg for line module
  if (key === "5") lineModuleIndex = 0;
  if (key === "6") lineModuleIndex = 1;
  if (key === "7") lineModuleIndex = 2;
  if (key === "8") lineModuleIndex = 3;
  if (key === "9") lineModuleIndex = 4;
}
```

游븷游빍九꽲잺 쯈u칠 cambios tienen los programas y 쯈u칠 puedes observar en la consola del 
editor de p5.js?

## Apply: Aplicaci칩n 游

### Actividad 04

#### Aplica lo aprendido

Vas a modificar la misma aplicaci칩n de la fase de aplicaci칩n de la 
unidad anterior para que soporte el protocolo de datos binarios. La aplicaci칩n 
del micro:bit debe ser la misma que usaste en la actividad anterior:

``` py
from microbit import *
import struct

uart.init(115200)
display.set_pixel(0, 0, 9)

while True:
    xValue = accelerometer.get_x()
    yValue = accelerometer.get_y()
    aState = button_a.is_pressed()
    bState = button_b.is_pressed()
    data = struct.pack('>2h2B', xValue, yValue, int(aState), int(bState))
    checksum = sum(data) % 256
    packet = b'\xAA' + data + bytes([checksum])
    uart.write(packet)
    sleep(100)
```


<Aside type="danger" title="evidencias para esta actividad">
游븷游빍九꽲잺
1. Vas a documentar en tu bit치cora todo el proceso de construcci칩n de la aplicaci칩n, mostrando las 
pruebas intermedias que hiciste, los errores que encontraste y c칩mo los solucionaste.
2. Vas a realizar m칰ltiples experimentos analizando el comportamiento de la aplicaci칩n que construiste. 
Reporta el proceso de experimentaci칩n en la bit치cora. Con estas evidencias debes demostrar que has comprendido 
los conceptos y t칠cnicas vistas en esta unidad.
</Aside>


## Reflect: Consolidaci칩n y metacognici칩n 游뱂

### Actividad 05

En esta actividad te voy a proponer que consolides lo que trabajaste en esta unidad. Te voy presentar 
algunas preguntas y cuestiones para que analices y reflexiones.

<Aside type="danger" title="evidencias para esta actividad">
游븷游빍九꽲잺
Estas preguntas las puedes responder en tu bit치cora en la rama unidad5/reflect.
</Aside>

1. En la unidad anterior abordaste la construcci칩n de un protocolo ASCII. En 
esta unidad realizaste lo propio con un protocolo binario. Realiza una tabla 
donde compares, seg칰n la aplicaci칩n que modificaste en la fase de aplicaci칩n 
de ambas unidades, los siguientes aspectos: eficiencia, velocidad, facilidad, 
usos de recursos. Justifica con ejemplos concretos tomados de las aplicaciones 
modificadas.  
2. 쯇or qu칠 fue necesario introducir framing en el protocolo binario? 
3. 쮺칩mo funciona el framing?
4. 쯈u칠 es un car치cter de sincronizaci칩n?
5. 쯈u칠 es el checksum y para qu칠 sirve?
6. En la funci칩n ``readSerialData()`` del programa en p5.js:

- 쯈u칠 hace la funci칩n concat? 쯇or qu칠?

``` js 
function readSerialData() {
    let available = port.availableBytes();
    if (available > 0) {
        let newData = port.readBytes(available);
        serialBuffer = serialBuffer.concat(newData);
    }
```

- En la funci칩n ``readSerialData()`` tenemos un bucle que recorre el buffer solo 
si este tiene 8 o m치s bytes 쯇or qu칠?

``` js
  while (serialBuffer.length >= 8) {
    if (serialBuffer[0] !== 0xaa) {
      serialBuffer.shift(); 
      continue;
    }
```

- En el c칩digo anterior qu칠 significa ``0xaa``? 

- En el c칩digo anterior qu칠 hace la funci칩n ``shift`` y la instrucci칩n ``continue``? 쯇or qu칠?

- Si hay menos de 8 bytes qu칠 hace la instrucci칩n ``break``? 쯇or qu칠?

``` js
    if (serialBuffer.length < 8) break;
```

- 쮺u치l es la diferencia entre ``slice`` y ``splice``? 쯇or qu칠 se usa ``splice`` justo despu칠s de ``slice``?  

``` js
let packet = serialBuffer.slice(0, 8);
serialBuffer.splice(0, 8); 
```

- A la siguiente parte del c칩digo se le conoce como programaci칩n funcional 
쮺칩mo opera la funci칩n reduce? 

``` js
    let computedChecksum = dataBytes.reduce((acc, val) => acc + val, 0) % 256;
```

- 쯇or qu칠 se compara el checksum enviado con el calculado? 쯇ara qu칠 sirve esto?

``` js
if (computedChecksum !== receivedChecksum) {
    console.log("Checksum error in packet");
    continue; 
}
```

- En el c칩digo anterior qu칠 hace la instrucci칩n ``continue``? 쯇or qu칠?

- 쯈u칠 es un DataView? 쯇ara qu칠 se usa?

``` js
let buffer = new Uint8Array(dataBytes).buffer;
let view = new DataView(buffer);
```

- 쯇or qu칠 es necesario hacer estas conversiones y no simplemente 
se toman tal cual los datos del buffer?

``` js
    microBitX = view.getInt16(0) + windowWidth / 2;
    microBitY = view.getInt16(2) + windowHeight / 2;
    microBitAState = view.getUint8(4) === 1;
    microBitBState = view.getUint8(5) === 1;
```



