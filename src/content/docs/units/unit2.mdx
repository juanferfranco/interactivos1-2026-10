---
title: Unidad 2
unitId: unit2
---
import { Aside } from '@astrojs/starlight/components';


## Introducci√≥n üìú

En esta unidad vamos a profundizar un poco m√°s en la programaci√≥n 
del computador embebido o micro:bit. Vamos a estudiar una t√©cnica
de programaci√≥n llamada m√°quinas de estados. Esta t√©cnica te permitir√° 
crear programas m√°s complejos y con mayor control sobre el flujo 
de ejecuci√≥n. Es importante que reconozcas que esta t√©cnica de 
programaci√≥n no es exclusiva del micro:bit, sino que se utiliza 
en muchos otros lenguajes de programaci√≥n y plataformas, por lo 
que es una habilidad valiosa para cualquier ingeniero en dise√±o 
de entretenimiento digital. En la pr√≥xima unidad ver√°s c√≥mo podr√°s 
transferir esta t√©cnica a otro lenguaje de programaci√≥n y plataforma.

## R√∫brica de evaluaci√≥n de la unidad üìù

:::note[Transparencia]
Esta r√∫brica se socializa antes de la sustentaci√≥n. La sustentaci√≥n se 
basa en lo presentado en la aplicaci√≥n y lo documentado en la bit√°cora. 
:::

### Requisito de salida (condici√≥n necesaria)

:::caution[Para poder cerrar la evaluaci√≥n y registrar la nota]
La **bit√°cora de reflexi√≥n** debe estar diligenciada antes de terminar 
la sesi√≥n final y debe ser ense√±ada al profesor antes de abandonar el aula.
La presentaci√≥n de la bit√°cora de reflexi√≥n es un requisito indispensable 
para montar la nota final en la plataforma acad√©mica. Si no se cumple este 
requisito, la nota final de la unidad ser√° 0.0.
:::

---

### R√∫brica anal√≠tica

:::tip[Evidencias evaluadas]

1) Funcionamiento de la aplicaci√≥n + documentaci√≥n en bit√°cora.
2) Sustentaci√≥n a partir de la app y la bit√°cora de aplicaci√≥n.

:::

| Criterio (peso) | Cumple plenamente (5.0) | Se cumple medianamente (4.0)| Problemas importantes (3.0)| Falta comprensi√≥n b√°sica (2.0) | No hay evidencia (0.0)
|---|---|---|---|---|---|
| **1. Aplicaci√≥n + bit√°cora (40%)** | La app se ejecuta sin fallos en el entorno acordado. Evidencia completa y verificable en bit√°cora. Todo consistente con lo mostrado en la demo. | La app funciona y cumple lo esencial. La bit√°cora permite verificar, pero hay **1‚Äì2 vac√≠os menores**| La app funciona parcialmente o depende de condiciones no declaradas. Bit√°cora con **vac√≠os importantes** o incompleta. | La app no corre o no demuestra lo requerido. La bit√°cora no permite verificaci√≥n de la app.| No se entregaron evidencias o no se puede acceder a ellas |
|Evaluaci√≥n||||||
| **2. Sustentaci√≥n (60%)** | Responde a las preguntas con precisi√≥n, conectando: **(a) lo que se ve**, **(b) c√≥mo est√° hecho**, y **(c) por qu√©**. Usa su bit√°cora para justificar decisiones. Reconoce l√≠mites/errores y propone c√≥mo probar/mejorar. | Respuestas correctas pero con **imprecisiones menores** o justificaci√≥n superficial. Usa parcialmente la bit√°cora para sustentar. | Responde solo ‚Äúqu√© hizo‚Äù pero le cuesta explicar ‚Äúc√≥mo‚Äù o ‚Äúpor qu√©‚Äù. Necesita gu√≠a para conectar con su propia evidencia/bit√°cora. | No logra responder de forma coherente o responde sin relaci√≥n con lo presentado/documentado. Evidencia falta de comprensi√≥n b√°sica del trabajo entregado. | No se entregaron evidencias o no se puede acceder a ellas |
|Evaluaci√≥n||||||
---

:::tip[C√°lculo de la nota]

$$
Nota = C_1*0.4  + C_2*0.6
$$

:::

---

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

Analizar√°s y aplicar√°s la t√©cnica de m√°quinas de estados para el dise√±o 
y programaci√≥n de aplicaciones interactivas. Recuerda que en esta 
unidad aplicar√°s lo aprendido al micro:bit, pero POR FAVOR no pierdas 
de vista que es una t√©cnica de programaci√≥n general que puedes aplicar
en muchos otros lenguajes y plataformas.

### Actividad 01

#### Analizando un programa con una m√°quina de estados simple

Analicemos juntos el siguiente c√≥digo identificando estados, eventos y acciones. Responde las preguntas planteadas.

``` py
from microbit import *
import utime

class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration
        
        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active:
            if utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
                self.active = False
                self.owner.post_event(self.event)


class Pixel:
    def __init__(self,_x,_y,_interval):
        self.event_queue = []
        self.timers = []
        self.x = _x
        self.y = _y
        self.pixelState = 0
        self.myTimer = self.createTimer("Timeout",_interval)

        self.estado_actual = None
        self.transicion_a(self.estado_waitTimeout)

    def createTimer(self,event,duration):
        t = Timer(self, event, duration)
        self.timers.append(t)
        return t

    def post_event(self, ev):
        self.event_queue.append(ev)

    def update(self):
        # 1. Actualizar todos los timers internos autom√°ticamente
        for t in self.timers:
            t.update()
        
        # 2. Procesar la cola de eventos resultante
        while len(self.event_queue) > 0:
            ev = self.event_queue.pop(0)
            if self.estado_actual:
                self.estado_actual(ev)

    def transicion_a(self, nuevo_estado):
        if self.estado_actual: self.estado_actual("EXIT")
        self.estado_actual = nuevo_estado
        self.estado_actual("ENTRY")

    def estado_waitTimeout(self, ev):
        if ev == "ENTRY":
            self.pixelState = 9
            display.set_pixel(self.x,self.y,self.pixelState)
            self.myTimer.start()
        elif ev == "Timeout":
            if self.pixelState == 0:
                self.pixelState = 9
                self.myTimer.start()
            else: 
                self.pixelState = 0
                self.myTimer.start()
            
            display.set_pixel(self.x,self.y,self.pixelState)

pixel1 = Pixel(0,0,1000)
pixel2 = Pixel(4,4,600)

while True:
    pixel1.update()
    pixel2.update()
    utime.sleep_ms(20)
```

![Pixel State Machine](../../../assets/pixelStateMachine.svg)

:::caution[üì§ Bit√°cora] 
Escribe en tu bit√°cora lo siguiente:

1. ¬øCu√°les son los estados en el programa? 
2. ¬øCu√°les son los eventos/inputs en el programa?
3. ¬øCu√°les son las acciones en el programa?
:::

## Seek: Investigaci√≥n üîé

### Actividad 02

#### Implementando un sem√°foro con m√°quinas de estados

Implementemos juntos un sem√°foro simple utilizando una m√°quina de 
estados en Micropython. Representaremos cada color del sem√°foro con 
un LED del display del micro:bit. La secuencia de cambio del sem√°foro 
ser√° 2 segundos en rojo, 1 segundo en verde, 0.5 segundos en amarillo 
y regresa a rojo repitiendo el ciclo.

:::caution[üì§ Bit√°cora]
1. Escribe el c√≥digo que soluciona este problema en tu bit√°cora.
2. Identifica los estados, eventos y acciones en tu c√≥digo.
:::

