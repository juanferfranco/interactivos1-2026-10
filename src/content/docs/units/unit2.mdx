---
title: Unidad 2
unitId: unit2
---
import { Aside } from '@astrojs/starlight/components';


## IntroducciÃ³n ğŸ“œ

En esta unidad vamos a profundizar un poco mÃ¡s en la programaciÃ³n 
del computador embebido o micro:bit. Vamos a estudiar una tÃ©cnica
de programaciÃ³n llamada mÃ¡quinas de estados. Esta tÃ©cnica te permitirÃ¡ 
crear programas mÃ¡s complejos y con mayor control sobre el flujo 
de ejecuciÃ³n. Es importante que reconozcas que esta tÃ©cnica de 
programaciÃ³n no es exclusiva del micro:bit, sino que se utiliza 
en muchos otros lenguajes de programaciÃ³n y plataformas, por lo 
que es una habilidad valiosa para cualquier ingeniero en diseÃ±o 
de entretenimiento digital. En la prÃ³xima unidad verÃ¡s cÃ³mo podrÃ¡s 
transferir esta tÃ©cnica a otro lenguaje de programaciÃ³n y plataforma.

## RÃºbrica de evaluaciÃ³n de la unidad ğŸ“

:::note[Transparencia]
Esta rÃºbrica se socializa antes de la sustentaciÃ³n. La sustentaciÃ³n se 
basa en lo presentado en la aplicaciÃ³n y lo documentado en la bitÃ¡cora. 
:::

### Requisito de salida (condiciÃ³n necesaria)

:::caution[Para poder cerrar la evaluaciÃ³n y registrar la nota]
La **bitÃ¡cora de reflexiÃ³n** debe estar diligenciada antes de terminar 
la sesiÃ³n final y debe ser enseÃ±ada al profesor antes de abandonar el aula.
La presentaciÃ³n de la bitÃ¡cora de reflexiÃ³n es un requisito indispensable 
para montar la nota final en la plataforma acadÃ©mica. Si no se cumple este 
requisito, la nota final de la unidad serÃ¡ 0.0.
:::

---

### RÃºbrica analÃ­tica

:::tip[Evidencias evaluadas]

1) Funcionamiento de la aplicaciÃ³n + documentaciÃ³n en bitÃ¡cora.
2) SustentaciÃ³n a partir de la app y la bitÃ¡cora de aplicaciÃ³n.

:::

| Criterio (peso) | Cumple plenamente (5.0) | Se cumple medianamente (4.0)| Problemas importantes (3.0)| Falta comprensiÃ³n bÃ¡sica (2.0) | No hay evidencia (0.0)
|---|---|---|---|---|---|
| **1. AplicaciÃ³n + bitÃ¡cora (40%)** | La app se ejecuta sin fallos en el entorno acordado. Evidencia completa y verificable en bitÃ¡cora. Todo consistente con lo mostrado en la demo. | La app funciona y cumple lo esencial. La bitÃ¡cora permite verificar, pero hay **1â€“2 vacÃ­os menores**| La app funciona parcialmente o depende de condiciones no declaradas. BitÃ¡cora con **vacÃ­os importantes** o incompleta. | La app no corre o no demuestra lo requerido. La bitÃ¡cora no permite verificaciÃ³n de la app.| No se entregaron evidencias o no se puede acceder a ellas |
|EvaluaciÃ³n||||||
| **2. SustentaciÃ³n (60%)** | Responde a las preguntas con precisiÃ³n, conectando: **(a) lo que se ve**, **(b) cÃ³mo estÃ¡ hecho**, y **(c) por quÃ©**. Usa su bitÃ¡cora para justificar decisiones. Reconoce lÃ­mites/errores y propone cÃ³mo probar/mejorar. | Respuestas correctas pero con **imprecisiones menores** o justificaciÃ³n superficial. Usa parcialmente la bitÃ¡cora para sustentar. | Responde solo â€œquÃ© hizoâ€ pero le cuesta explicar â€œcÃ³moâ€ o â€œpor quÃ©â€. Necesita guÃ­a para conectar con su propia evidencia/bitÃ¡cora. | No logra responder de forma coherente o responde sin relaciÃ³n con lo presentado/documentado. Evidencia falta de comprensiÃ³n bÃ¡sica del trabajo entregado. | No se entregaron evidencias o no se puede acceder a ellas |
|EvaluaciÃ³n||||||
---

:::tip[CÃ¡lculo de la nota]

$$
Nota = C_1*0.4  + C_2*0.6
$$

:::

---

## Set: Â¿QuÃ© aprenderÃ¡s en esta unidad? ğŸ’¡

AnalizarÃ¡s y aplicarÃ¡s la tÃ©cnica de mÃ¡quinas de estados para el diseÃ±o 
y programaciÃ³n de aplicaciones interactivas. Recuerda que en esta 
unidad aplicarÃ¡s lo aprendido al micro:bit, pero POR FAVOR no pierdas 
de vista que es una tÃ©cnica de programaciÃ³n general que puedes aplicar
en muchos otros lenguajes y plataformas.

### Actividad 01

#### Analizando un programa con una mÃ¡quina de estados simple

Analicemos juntos el siguiente cÃ³digo identificando estados, eventos y acciones. Responde las preguntas planteadas.

``` py
from microbit import *
import utime

class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration
        
        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active:
            if utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
                self.active = False
                self.owner.post_event(self.event)


class Pixel:
    def __init__(self,_x,_y,_interval):
        self.event_queue = []
        self.timers = []
        self.x = _x
        self.y = _y
        self.pixelState = 0
        self.myTimer = self.createTimer("Timeout",_interval)

        self.estado_actual = None
        self.transicion_a(self.estado_waitTimeout)

    def createTimer(self,event,duration):
        t = Timer(self, event, duration)
        self.timers.append(t)
        return t

    def post_event(self, ev):
        self.event_queue.append(ev)

    def update(self):
        # 1. Actualizar todos los timers internos automÃ¡ticamente
        for t in self.timers:
            t.update()
        
        # 2. Procesar la cola de eventos resultante
        while len(self.event_queue) > 0:
            ev = self.event_queue.pop(0)
            if self.estado_actual:
                self.estado_actual(ev)

    def transicion_a(self, nuevo_estado):
        if self.estado_actual: self.estado_actual("EXIT")
        self.estado_actual = nuevo_estado
        self.estado_actual("ENTRY")

    def estado_waitTimeout(self, ev):
        if ev == "ENTRY":
            self.pixelState = 9
            display.set_pixel(self.x,self.y,self.pixelState)
            self.myTimer.start()
        elif ev == "Timeout":
            if self.pixelState == 0:
                self.pixelState = 9
                self.myTimer.start()
            else: 
                self.pixelState = 0
                self.myTimer.start()
            
            display.set_pixel(self.x,self.y,self.pixelState)

pixel1 = Pixel(0,0,1000)
pixel2 = Pixel(4,4,600)

while True:
    pixel1.update()
    pixel2.update()
    utime.sleep_ms(20)
```

![pixel1 Sequence Diagram](../../../assets/pixelSequence.svg)

![Pixel State Machine](../../../assets/pixelStateMachine.svg)

:::caution[ğŸ“¤ BitÃ¡cora] 
Escribe en tu bitÃ¡cora lo siguiente:

1. Â¿CuÃ¡les son los estados en el programa? 
2. Â¿CuÃ¡les son los eventos en el programa?
3. Â¿CuÃ¡les son las acciones en el programa?
:::

## Seek: InvestigaciÃ³n ğŸ”

### Actividad 02

#### Implementando un semÃ¡foro con mÃ¡quinas de estados

Implementemos juntos un semÃ¡foro simple utilizando una mÃ¡quina de 
estados en Micropython. Representaremos cada color del semÃ¡foro con 
un LED del display del micro:bit. La secuencia de cambio del semÃ¡foro 
serÃ¡ 2 segundos en rojo --> 1 segundo en verde --> 0.5 segundos en amarillo 
--> regresa a rojo --> repite el ciclo.




:::caution[ğŸ“¤ BitÃ¡cora]
1. Escribe el cÃ³digo que soluciona este problema en tu bitÃ¡cora.
2. Identifica los estados, eventos y acciones en tu cÃ³digo.
:::


### Actividad 03

#### MÃ¡quina de estados con botones

:::caution[ğŸ“¤ BitÃ¡cora]
:::

## Apply: AplicaciÃ³n ğŸ› 

### Actividad 04

#### CronÃ³metro interactivo con mÃ¡quina de estados

:::caution[ğŸ“¤ BitÃ¡cora]
:::

## Reflect: ConsolidaciÃ³n y metacogniciÃ³n ğŸ¤”

### Actividad 05

Esta actividad es un reto final. La idea es modificar el cronÃ³metro
interactivo de modo que puedas controlarlo tambiÃ©n con p5.js ademÃ¡s 
de los botones del micro:bit.

:::caution[ğŸ“¤ BitÃ¡cora]
1. Explica cÃ³mo resolviste el reto.
2. Coloca el cÃ³digo final en tu bitÃ¡cora tanto para el micro:bit 
   como para p5.js.
:::