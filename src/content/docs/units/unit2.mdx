---
title: Unidad 2
unitId: unit2
---
import { Aside } from '@astrojs/starlight/components';


## Introducci√≥n üìú

En esta unidad vamos a profundizar un poco m√°s en la programaci√≥n 
del computador embebido o micro:bit. Vamos a estudiar una t√©cnica
de programaci√≥n llamada m√°quinas de estados. Esta t√©cnica te permitir√° 
crear programas m√°s complejos y con mayor control sobre el flujo 
de ejecuci√≥n. Es importante que reconozcas que esta t√©cnica de 
programaci√≥n no es exclusiva del micro:bit, sino que se utiliza 
en muchos otros lenguajes de programaci√≥n y plataformas, por lo 
que es una habilidad valiosa para cualquier ingeniero en dise√±o 
de entretenimiento digital. En la pr√≥xima unidad ver√°s c√≥mo podr√°s 
transferir esta t√©cnica a otro lenguaje de programaci√≥n y plataforma.

## R√∫brica de evaluaci√≥n de la unidad üìù

:::note[Transparencia]
Esta r√∫brica se socializa antes de la sustentaci√≥n. La sustentaci√≥n se 
basa en lo presentado en la aplicaci√≥n y lo documentado en la bit√°cora. 
:::

### Requisito de salida (condici√≥n necesaria)

:::caution[Para poder cerrar la evaluaci√≥n y registrar la nota]
La **bit√°cora de reflexi√≥n** debe estar diligenciada antes de terminar 
la sesi√≥n final y debe ser ense√±ada al profesor antes de abandonar el aula.
La presentaci√≥n de la bit√°cora de reflexi√≥n es un requisito indispensable 
para montar la nota final en la plataforma acad√©mica. Si no se cumple este 
requisito, la nota final de la unidad ser√° 0.0.
:::

---

### R√∫brica anal√≠tica

:::tip[Evidencias evaluadas]

1) Funcionamiento de la aplicaci√≥n + documentaci√≥n en bit√°cora.
2) Sustentaci√≥n a partir de la app y la bit√°cora de aplicaci√≥n.

:::

| Criterio (peso) | Cumple plenamente (5.0) | Se cumple medianamente (4.0)| Problemas importantes (3.0)| Falta comprensi√≥n b√°sica (2.0) | No hay evidencia (0.0)
|---|---|---|---|---|---|
| **1. Aplicaci√≥n + bit√°cora (40%)** | La app se ejecuta sin fallos en el entorno acordado. Evidencia completa y verificable en bit√°cora. Todo consistente con lo mostrado en la demo. | La app funciona y cumple lo esencial. La bit√°cora permite verificar, pero hay **1‚Äì2 vac√≠os menores**| La app funciona parcialmente o depende de condiciones no declaradas. Bit√°cora con **vac√≠os importantes** o incompleta. | La app no corre o no demuestra lo requerido. La bit√°cora no permite verificaci√≥n de la app.| No se entregaron evidencias o no se puede acceder a ellas |
|Evaluaci√≥n||||||
| **2. Sustentaci√≥n (60%)** | Responde a las preguntas con precisi√≥n, conectando: **(a) lo que se ve**, **(b) c√≥mo est√° hecho**, y **(c) por qu√©**. Usa su bit√°cora para justificar decisiones. Reconoce l√≠mites/errores y propone c√≥mo probar/mejorar. | Respuestas correctas pero con **imprecisiones menores** o justificaci√≥n superficial. Usa parcialmente la bit√°cora para sustentar. | Responde solo ‚Äúqu√© hizo‚Äù pero le cuesta explicar ‚Äúc√≥mo‚Äù o ‚Äúpor qu√©‚Äù. Necesita gu√≠a para conectar con su propia evidencia/bit√°cora. | No logra responder de forma coherente o responde sin relaci√≥n con lo presentado/documentado. Evidencia falta de comprensi√≥n b√°sica del trabajo entregado. | No se entregaron evidencias o no se puede acceder a ellas |
|Evaluaci√≥n||||||
---

:::tip[C√°lculo de la nota]

$$
Nota = C_1*0.4  + C_2*0.6
$$

:::

---

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

Analizar√°s y aplicar√°s la t√©cnica de m√°quinas de estados para el dise√±o 
y programaci√≥n de aplicaciones interactivas. Recuerda que en esta 
unidad aplicar√°s lo aprendido al micro:bit, pero POR FAVOR no pierdas 
de vista que es una t√©cnica de programaci√≥n general que puedes aplicar
en muchos otros lenguajes y plataformas.

### Actividad 01

#### Analizando un programa con una m√°quina de estados simple

Analicemos juntos el siguiente c√≥digo identificando estados, eventos y acciones. Esta aplicaci√≥n controla dos pixeles del display del micro:bit 
que parpadean a diferentes velocidades. Para poder controlar el tiempo de parpadeo se utiliza una clase Timer que permite iniciar, detener y actualizar un temporizador. 
Nota que esta t√©cnica de manejo del tiempo es diferente a la que vimos en la unidad anterior con sleep(). Ahora no es posible utilizar sleep() porque detendr√≠a 
toda la ejecuci√≥n del programa y no podr√≠amos manejar dos pixeles de manera concurrente. Te voy a mostrar dos diaframas primero para que puedas entender mejor la
estructura del programa y luego el c√≥digo completo.

![pixel1 Sequence Diagram](../../../assets/pixelSequence.svg)

<details>
<summary>Fuente del diagrama anterior</summary>
```
@startuml

<style>
root {
  BackgroundColor #4a556822 
  FontColor #718096
  LineColor #718096
  Margin 30
  Padding 10
}

sequenceDiagram {
  participant {
    BackgroundColor #edf2f7
    LineColor #4a5568
    FontColor #2d3748
  }
  lifeLine {
    LineColor #718096
  }
  arrow {
    LineColor #718096
    FontColor #718096
  }
}
</style>

title App Sequence Diagram for pixel1

actor Main
participant "pixel1:Pixel" as P1
participant "pixel1.myTimer:Timer" as T1
participant "display" as D

Main -> P1 : Pixel(0,0,1000)
activate P1
P1 -> D : set_pixel(0,0,9)
P1 -> T1 : start()
deactivate P1


loop while True (cada ~20ms)
  Main -> P1 : update()
  activate P1
    P1 -> T1 : update()
    activate T1
      alt Ocurre Timeout
        T1 -> P1 : post_event("Timeout")
      end
    deactivate T1

    P1 -> P1: procesa eventos
    
  deactivate P1

end

@enduml

```

</details>

![Pixel State Machine](../../../assets/pixelStateMachine.svg)

<details>
<summary>Fuente del diagrama anterior</summary>
```
@startuml

<style>
root {
  BackgroundColor #4a556822 
  FontColor #718096
  LineColor #718096
  Margin 30
  Padding 10
}

stateDiagram {
  state {
    BackgroundColor #edf2f7
    LineColor #4a5568
    FontColor #2d3748
    RoundCorner 10
  }
  arrow {
    LineColor #718096
    FontColor #718096
  }
}
</style>


title Pixel - UML State Machine

[*] --> WaitTimeout : Pixel() (constructor)
WaitTimeout : entry /\n  pixelState = 9\n  display.set_pixel(x,y,pixelState)\n  myTimer.start()
WaitTimeout : \n Timeout /\n  if pixelState==0 then pixelState=9 else pixelState=0\n  myTimer.start()\n  display.set_pixel(x,y,pixelState)

@enduml

```

</details>


``` py
from microbit import *
import utime

class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration
        
        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active:
            if utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
                self.active = False
                self.owner.post_event(self.event)


class Pixel:
    def __init__(self,_x,_y,_interval):
        self.event_queue = []
        self.timers = []
        self.x = _x
        self.y = _y
        self.pixelState = 0
        self.myTimer = self.createTimer("Timeout",_interval)

        self.estado_actual = None
        self.transicion_a(self.estado_waitTimeout)

    def createTimer(self,event,duration):
        t = Timer(self, event, duration)
        self.timers.append(t)
        return t

    def post_event(self, ev):
        self.event_queue.append(ev)

    def update(self):
        # 1. Actualizar todos los timers internos autom√°ticamente
        for t in self.timers:
            t.update()
        
        # 2. Procesar la cola de eventos resultante
        while len(self.event_queue) > 0:
            ev = self.event_queue.pop(0)
            if self.estado_actual:
                self.estado_actual(ev)

    def transicion_a(self, nuevo_estado):
        if self.estado_actual: self.estado_actual("EXIT")
        self.estado_actual = nuevo_estado
        self.estado_actual("ENTRY")

    def estado_waitTimeout(self, ev):
        if ev == "ENTRY":
            self.pixelState = 9
            display.set_pixel(self.x,self.y,self.pixelState)
            self.myTimer.start()
        elif ev == "Timeout":
            if self.pixelState == 0:
                self.pixelState = 9
                self.myTimer.start()
            else: 
                self.pixelState = 0
                self.myTimer.start()
            
            display.set_pixel(self.x,self.y,self.pixelState)

pixel1 = Pixel(0,0,1000)
pixel2 = Pixel(4,4,600)

while True:
    pixel1.update()
    pixel2.update()
    utime.sleep_ms(20)
```

Otra manera de modelar la soluci√≥n del problema es esta:

![Pixel State Machine 2](../../../assets/pixelStateMachine2.svg)

<details>
<summary>Fuente del diagrama anterior</summary>

```
@startuml

<style>
root {
  BackgroundColor #4a556822 
  FontColor #718096
  LineColor #718096
  Margin 30
  Padding 10
}

stateDiagram {
  state {
    BackgroundColor #edf2f7
    LineColor #4a5568
    FontColor #2d3748
    RoundCorner 10
  }
  arrow {
    LineColor #718096
    FontColor #718096
  }
}
</style>


title Pixel - UML State Machine

[*] --> WaitInON : Pixel() (constructor)
WaitInON : entry /\n  pixelState = 9\n  display.set_pixel(x,y,pixelState)\n  myTimer.start()
WaitInON --> WaitInOFF : \n Timeout /
WaitInOFF: entry /\n  pixelState = 0\n  display.set_pixel(x,y,pixelState)\n  myTimer.start()
WaitInOFF --> WaitInON : \n Timeout /

@enduml
```
</details>


```py
from microbit import *
import utime

class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration

        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active:
            if utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
                self.active = False
                self.owner.post_event(self.event)


class Pixel:
    def __init__(self,_x,_y,_interval):
        self.event_queue = []
        self.timers = []
        self.x = _x
        self.y = _y
        self.pixelState = 0
        self.myTimer = self.createTimer("Timeout",_interval)

        self.estado_actual = None
        self.transicion_a(self.estado_waitInON)

    def createTimer(self,event,duration):
        t = Timer(self, event, duration)
        self.timers.append(t)
        return t

    def post_event(self, ev):
        self.event_queue.append(ev)

    def update(self):
        # 1. Actualizar todos los timers internos autom√°ticamente
        for t in self.timers:
            t.update()

        # 2. Procesar la cola de eventos resultante
        while len(self.event_queue) > 0:
            ev = self.event_queue.pop(0)
            if self.estado_actual:
                self.estado_actual(ev)

    def transicion_a(self, nuevo_estado):
        if self.estado_actual: self.estado_actual("EXIT")
        self.estado_actual = nuevo_estado
        self.estado_actual("ENTRY")

    def estado_waitInON(self, ev):
        if ev == "ENTRY":
            self.pixelState = 9
            display.set_pixel(self.x,self.y,self.pixelState)
            self.myTimer.start()
        elif ev == "Timeout":
            self.transicion_a(self.estado_waitInOFF)

    def estado_waitInOFF(self, ev):
        if ev == "ENTRY":
            self.pixelState = 0
            display.set_pixel(self.x,self.y,self.pixelState)
            self.myTimer.start()
        elif ev == "Timeout":
            self.transicion_a(self.estado_waitInON)

pixel1 = Pixel(0,0,1000)
pixel2 = Pixel(4,4,600)

while True:
    pixel1.update()
    pixel2.update()
    utime.sleep_ms(20)
```



:::caution[üì§ Bit√°cora] 
Escribe en tu bit√°cora lo siguiente:

1. ¬øCu√°les son los estados en el programa? 
2. ¬øCu√°les son los eventos en el programa?
3. ¬øCu√°les son las acciones en el programa?
:::

## Seek: Investigaci√≥n üîé

### Actividad 02

#### Implementando un sem√°foro con m√°quinas de estados

Implementemos juntos un sem√°foro simple utilizando una m√°quina de 
estados en Micropython. Representaremos cada color del sem√°foro con 
un LED del display del micro:bit. La secuencia de cambio del sem√°foro 
ser√° 2 segundos en rojo --> 1 segundo en verde --> 0.5 segundos en amarillo 
--> regresa a rojo --> repite el ciclo.


```py
from microbit import *
import utime

class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration
        
        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active:
            if utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
                self.active = False
                self.owner.post_event(self.event)


class Semaforo:
    def __init__(self,_x,_y,_timeInRed,_timeInGreen,_timeInYellow):
        self.event_queue = []
        self.timers = []
        self.x = _x
        self.y = _y
        self.timeInRed = _timeInRed
        self.timeInGreen = _timeInGreen
        self.timeInYellow = _timeInYellow
        self.myTimer = self.createTimer("Timeout",self.timeInRed)

        self.estado_actual = None
        self.transicion_a(self.estado_waitInRed)

    def createTimer(self,event,duration):
        t = Timer(self, event, duration)
        self.timers.append(t)
        return t

    def post_event(self, ev):
        self.event_queue.append(ev)

    def update(self):
        # 1. Actualizar todos los timers internos autom√°ticamente
        for t in self.timers:
            t.update()
        
        # 2. Procesar la cola de eventos resultante
        while len(self.event_queue) > 0:
            ev = self.event_queue.pop(0)
            if self.estado_actual:
                self.estado_actual(ev)

    def transicion_a(self, nuevo_estado):
        if self.estado_actual: self.estado_actual("EXIT")
        self.estado_actual = nuevo_estado
        self.estado_actual("ENTRY")

    def clear(self):
        display.set_pixel(self.x,self.y,0)
        display.set_pixel(self.x,self.y+1,0)
        display.set_pixel(self.x,self.y+2,0)

    def estado_waitInRed(self, ev):
        if ev == "ENTRY":
            self.clear()
            display.set_pixel(self.x,self.y,9)
            self.myTimer.start(self.timeInRed)
        if ev == "Timeout":
            display.set_pixel(self.x,self.y,0)
            self.transicion_a(self.estado_waitInGreen)

    def estado_waitInGreen(self, ev):
        if ev == "ENTRY":
            self.clear()
            display.set_pixel(self.x,self.y+2,9)
            self.myTimer.start(self.timeInGreen)
            
        if ev == "Timeout":
            display.set_pixel(self.x,self.y+2,0)
            self.transicion_a(self.estado_waitInYellow)

        if ev == "A":
            display.set_pixel(self.x,self.y+2,0)
            self.transicion_a(self.estado_waitInYellow)

    def estado_waitInYellow(self, ev):
        if ev == "ENTRY":
            self.clear()
            display.set_pixel(self.x,self.y+1,9)
            self.myTimer.start(self.timeInYellow)
        if ev == "Timeout":
            display.set_pixel(self.x,self.y+1,0)
            self.transicion_a(self.estado_waitInRed)

semaforo1 = Semaforo(0,0,2000,1000,500)

while True:
    semaforo1.update()
    utime.sleep_ms(20)

```

Antes de continuar con las actividades propuestas para esta actividad, voy a mostrarte 
c√≥mo implement√© en plantUML la m√°quina de estados del caso anterior. Esto te servir√° 
de gu√≠a para que puedas construir la m√°quina de estados de esta actividad. Pega 
el siguiente c√≥digo en el editor de plantUML que puedes encontrar 
[aqu√≠](https://editor.plantuml.com/).

```plantuml
@startuml
title Pixel - UML State Machine

[*] --> WaitTimeout : Pixel() (constructor)
WaitTimeout : entry /\n  pixelState = 9\n  display.set_pixel(x,y,pixelState)\n  myTimer.start()
WaitTimeout --> WaitTimeout : Timeout /\n  if pixelState==0 then pixelState=9 else pixelState=0\n  myTimer.start()\n  display.set_pixel(x,y,pixelState)

@enduml

```


:::caution[üì§ Bit√°cora]
1. Vas a realizar una modificaci√≥n. Cuando el sem√°foro est√© en verde, 
   si se presiona el bot√≥n A, el sem√°foro debe cambiar inmediatamente 
   a amarillo (sin esperar a que termine el tiempo de verde). El evento 
   que se debe postear es "A" (post_event("A")).
2. Construye la m√°quina de estados que modela el problema usando [PlantUML](https://plantuml.com/). 
Puedes encontrar el editor [aqu√≠](https://editor.plantuml.com/) y la documentaci√≥n b√°sica con 
ejemplos [aqu√≠](https://plantuml.com/state-diagram).
:::

### Actividad 03

#### M√°quina de estados con botones

Implementaremos juntos el siguiente programa que busca gestionar la concurrencia 
entre la secuencia de im√°genes y la respuesta a la pulsaci√≥n de botones.

Lee la siguiente descripci√≥n del problema y luego analiza la soluci√≥n 
implementada. Para el an√°lisis trata de observar estas preguntas:

* ¬øC√≥mo es posible estructurar una aplicaci√≥n usando una m√°quina de estados 
para poder atender varios eventos de manera concurrente?

* ¬øC√≥mo haces para probar que el programa est√° correcto?

**Descripci√≥n del problema**

Imagina un programa para el micro:bit que muestra diferentes im√°genes y que tambi√©n 
**reacciona de inmediato** si presionas un bot√≥n. Al iniciar, se muestra un 
coraz√≥n durante un segundo y medio. Despu√©s, el micro:bit cambia a 
un pacman que dura un segundo. Luego, aparece un ghost durante dos 
segundos, y el ciclo vuelve a comenzar.

Sin embargo, si en cualquier momento se presiona el bot√≥n A mientras est√° el coraz√≥n 
saltar√° inmediatamente al ghost. Si se presiona el bot√≥n A mientras est√° el pacman, 
saltar√° al coraz√≥n. Si se presiona el bot√≥n A mientras est√° el ghost, se mostrar√° el pacman.

![Game State Machine](../../../assets/gameStateMachine.svg)

<details>
<summary>Fuente del diagrama anterior</summary>

```plantuml
@startuml

title Game - UML State Machine

[*] --> waitInHeart : Game() (constructor)
waitInHeart : entry /\n  display.show(Image.HEART)\n  myTimer.start(timeInHeart)
waitInHeart --> waitInPacman : Timeout /
waitInHeart --> waitInGhost : A /
waitInPacman : entry /\n  display.show(Image.PACMAN)\n  myTimer.start(timeInPacman)
waitInPacman --> waitInGhost : Timeout /
waitInPacman --> waitInHeart : A /
waitInGhost : entry /\n  display.show(Image.GHOST)\n  myTimer.start(timeInGhost)
waitInGhost --> waitInHeart : Timeout /
waitInGhost --> waitInPacman : A /

@enduml

```
</details>


```py 
from microbit import *
import utime

class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration
        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active:
            if utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
                self.active = False
                self.owner.post_event(self.event)


class Game:
    def __init__(self):
        self.event_queue = []
        self.timers = []
        self.timeInHeart = 2500
        self.timeInPacman = 1000
        self.timeInGhost = 2000
        self.myTimer = self.createTimer("Timeout",self.timeInHeart)

        self.estado_actual = None
        self.transicion_a(self.estado_waitInHeart)

    def createTimer(self,event,duration):
        t = Timer(self, event, duration)
        self.timers.append(t)
        return t

    def post_event(self, ev):
        self.event_queue.append(ev)

    def update(self):
        # 1. Actualizar todos los timers internos autom√°ticamente
        for t in self.timers:
            t.update()
        
        # 2. Procesar la cola de eventos resultante
        while len(self.event_queue) > 0:
            ev = self.event_queue.pop(0)
            if self.estado_actual:
                self.estado_actual(ev)

    def transicion_a(self, nuevo_estado):
        if self.estado_actual: self.estado_actual("EXIT")
        self.estado_actual = nuevo_estado
        self.estado_actual("ENTRY")


    def estado_waitInHeart(self, ev):
        if ev == "ENTRY":
            display.show(Image.HEART)
            self.myTimer.start(self.timeInHeart)
        if ev == "Timeout":
            self.transicion_a(self.estado_waitInPacman)
        if ev == "A":
            self.transicion_a(self.estado_waitInGhost)


    def estado_waitInPacman(self, ev):
        if ev == "ENTRY":
            display.show(Image.PACMAN)
            self.myTimer.start(self.timeInPacman)
        if ev == "Timeout":
            self.transicion_a(self.estado_waitInGhost)
        if ev == "A":
            self.transicion_a(self.estado_waitInHeart)     

    def estado_waitInGhost(self, ev):
        if ev == "ENTRY":
            display.show(Image.GHOST)
            self.myTimer.start(self.timeInGhost)
        if ev == "Timeout":
            self.transicion_a(self.estado_waitInHeart)
        if ev == "A":
            self.transicion_a(self.estado_waitInPacman) 
        
game = Game()

while True:
    if button_a.was_pressed(): 
        game.post_event("A")
    game.update()
    utime.sleep_ms(20)

```



:::caution[üì§ Bit√°cora]
Vamos a tomarnos un momento para revisar de manera individual el c√≥digo y 
la m√°quina de estados modelada. ¬øHay algo que a√∫n no comprendes completamente?
:::

## Apply: Aplicaci√≥n üõ†

### Actividad 04

#### Temporizador interactivo con m√°quina de estados

:::caution[Importante]
La soluci√≥n a este problema TIENE algunas restricciones importantes. 
Si no cumples con estas restricciones, aunque tu aplicaci√≥n funcione 
correctamente, el criterio C1 de la r√∫brica anal√≠tica ser√° calificado 
con 0.0.

* Debes utilizar la misma arquitectura de m√°quina de estados que
hemos venido trabajando en las actividades anteriores. 
* Debes usar la clase Timer para gestionar el tiempo.
* Debes emplear la funci√≥n make_fill_images() para crear las im√°genes
del display y la funci√≥n display.show(FILL[n]) para mostrarlas.
* Debes usar los eventos "A", "B" y "S" para los botones y el gesto 
de shake respectivamente.
* NO PUEDES usar sleep() en la implementaci√≥n de la m√°quina de estados. Recuerda 
usar Timer para gestionar los tiempos.
:::

En un escape room se requiere construir una aplicaci√≥n para controlar una temporizador. 
El circuito de control de este est√° compuesto por tres sensores, denominados 
UP (bot√≥n A), DOWN (bot√≥n B) y ARMED (el gesto de shake de aceler√≥metro). 
Tiene dos actuadores o dispositivos de salida que ser√°n un display (la pantalla de LEDs) y 
un speaker.

**El controlador funciona as√≠:**

1. Inicia en modo de configuraci√≥n, es decir, sin hacer cuenta regresiva a√∫n, 
el temporizador est√° desarmado. El valor inicial del conteo regresivo es de 20 pixeles comenzando 
desde la parte superior izquierda del display y avanzando fila por fila hasta la parte inferior derecha.
Cada pixel representa 1 segundo.

2. En el modo de configuraci√≥n, los pulsadores A y B permiten aumentar o disminuir 
la cantidad de pixeles que contar√° el temporizador. 

3. El tiempo se puede programar entre 15 y 25 pixeles. 

4. Es obligatorio usar la clase Timer para gestionar el tiempo. No olvides que los tiempos 
est√°n en milisegundos, es decir, 1 segundo equivale a 1000 milisegundos.

5. Hacer shake (ARMED) arma el temporizador, es decir, inicia el conteo regresivo.

6. Una vez armado el temporizador, comienza la cuenta regresiva que ser√° visualizada 
en la pantalla de LED apagando un pixel cada segundo y comenzando desde el pixel 
de la parte inferior hasta el pixel de la parte superior izquierda.

7. Una vez el temporizador termine se debe mostrar en el display una calavera y
sonar el speaker. Para volver a modo de configuraci√≥n se debe presionar el bot√≥n A y 
el temporizador se reinicia a 20 pixeles quedando desarmado y listo para una nueva configuraci√≥n.

8. Al generar los eventos de los botones y el gesto de shake, recuerda usar
el m√©todo post_event("EVENTO") para enviar los eventos a la m√°quina de estados. Los 
eventos ser√° "A", "B" y "S" respectivamente.

Te dejo el c√≥digo base para que puedas iniciar tu desarrollo:

**Funci√≥n para crear las im√°genes de llenado del display:**

```py
def make_fill_images(on='9', off='0'):
    imgs = []
    for n in range(26): 
        rows = []
        k = 0
        for y in range(5):
            row = []
            for x in range(5):
                row.append(on if k < n else off)
                k += 1
            rows.append(''.join(row))
        imgs.append(Image(':'.join(rows)))
    return imgs

FILL = make_fill_images()
# Para mostrar usas display.show(FILL[n]) donde n ser√°
# un valor de 0 a 25
```

**Timer:**

```py
class Timer:
    def __init__(self, owner, event_to_post, duration):
        self.owner = owner
        self.event = event_to_post
        self.duration = duration
        self.start_time = 0
        self.active = False

    def start(self, new_duration=None):
        if new_duration is not None:
            self.duration = new_duration
        self.start_time = utime.ticks_ms()
        self.active = True

    def stop(self):
        self.active = False

    def update(self):
        if self.active:
            if utime.ticks_diff(utime.ticks_ms(), self.start_time) >= self.duration:
                self.active = False
                self.owner.post_event(self.event)
```

**Estructura b√°sica de una tarea con m√°quina de estados:**

```py
class Task:
    def __init__(self):
        self.event_queue = []
        self.timers = []
        # Personalizas el nombre del evento y la duraci√≥n
        self.myTimer = self.createTimer("Timeout",1000) 

        self.estado_actual = None
        self.transicion_a(self.estado_estado1)

    def createTimer(self,event,duration):
        t = Timer(self, event, duration)
        self.timers.append(t)
        return t

    def post_event(self, ev):
        self.event_queue.append(ev)

    def update(self):
        # 1. Actualizar todos los timers internos autom√°ticamente
        for t in self.timers:
            t.update()
        
        # 2. Procesar la cola de eventos resultante
        while len(self.event_queue) > 0:
            ev = self.event_queue.pop(0)
            if self.estado_actual:
                self.estado_actual(ev)

    def transicion_a(self, nuevo_estado):
        if self.estado_actual: self.estado_actual("EXIT")
        self.estado_actual = nuevo_estado
        self.estado_actual("ENTRY")


    def estado_estado1(self, ev):
        if ev == "ENTRY":
            pass
        if ev == "Timeout":
            pass

    def estado_estado2(self, ev):
        if ev == "ENTRY":
            pass
        if ev == "Timeout":
            pass
```

**El ciclo principal:**

```py
task = Task()
while True:
    # Aqu√≠ generas los eventos de los botones y el gesto
    if button_a.was_pressed(): 
        task.post_event("A")
    if button_b.was_pressed(): 
        task.post_event("B")
    if accelerometer.was_gesture("shake"):
        task.post_event("S")
        
    task.update()
    utime.sleep_ms(20)
```

:::caution[üì§ Bit√°cora]
1. Construye la m√°quina de estados que modela el problema usando [PlantUML](https://plantuml.com/). 
Puedes encontrar el editor [aqu√≠](https://editor.plantuml.com/) y la documentaci√≥n b√°sica con 
ejemplos [aqu√≠](https://plantuml.com/state-diagram).
2. Implementa el c√≥digo en Micropython y col√≥calo en tu bit√°cora. Recuerda que puedes 
usar el simulador de micro:bit en [este enlace](https://python.microbit.org/v/3).
:::

## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

### Actividad 05

Esta actividad es un reto final. La idea es modificar el temporizador
interactivo de modo que puedas controlarlo tambi√©n desde p5.js adem√°s 
de los botones del micro:bit. Usa las letras A, B y S para simular los 
botones UP, DOWN y ARMED respectivamente. Adem√°s, recuerda que en la unidad 
1 Actividad 03 ya tienes la receta para recibir mensajes desde p5.js al micro:bit. 
Ten presente que NO DEBES CAMBIAR la arquitectura de la aplicaci√≥n. La idea es que 
puedas extenderla a√±adiendo la funcionalidad de p5.js sin cambiar la estructura
de m√°quina de estados que ya tienes.

:::caution[üì§ Bit√°cora]
1. Explica c√≥mo resolviste el reto.
2. Coloca el c√≥digo final en tu bit√°cora tanto para el micro:bit 
   como para p5.js.
:::