---
title: Unidad 2
unitId: unit2
---

## Introducci칩n 游닆

En esta unidad vamos a profundizar un poco m치s en la programaci칩n del computador 
embebido o micro:bit. Vamos a estudiar una t칠cnicas de programaci칩n 
basada en m치quinas de estados que nos permitir치 crear programas m치s complejos y
con mayor control sobre el flujo de ejecuci칩n. Esta t칠cnica de programaci칩n 
no es exclusiva del micro:bit, sino que se utiliza en muchos otros lenguajes de
programaci칩n y plataformas, por lo que es una habilidad valiosa para cualquier 
ingeniero en dise침o de entretenimiento digital. En la pr칩xima unidad ver치s 
c칩mo podr치s transferir esta t칠cnica a otros lenguajes de programaci칩n y plataforma.

## Set: 쯈u칠 aprender치s en esta unidad? 游눠

Vas a resolver problemas de programaci칩n en el micro:bit utilizando m치quinas de estados.

### Actividad 01

#### Analizando un programa con una m치quina de estados simple

Analicemos juntos el siguiente c칩digo identificando estados, eventos y acciones. Responde las preguntas planteadas.

``` py

from microbit import *
import utime

class Pixel:
    def __init__(self,pixelX,pixelY,initState,interval):
        self.state = "Init"
        self.startTime = 0
        self.interval = interval
        self.pixelX = pixelX
        self.pixelY = pixelY
        self.pixelState = initState

    def update(self):

        if self.state == "Init":
            self.startTime = utime.ticks_ms()
            self.state = "WaitTimeout"
            display.set_pixel(self.pixelX,self.pixelY,self.pixelState)

        elif self.state == "WaitTimeout":
            if utime.ticks_diff(utime.ticks_ms(),self.startTime) > self.interval:
                self.startTime = utime.ticks_ms()
                if self.pixelState == 9:
                    self.pixelState = 0
                else:
                    self.pixelState = 9
                display.set_pixel(self.pixelX,self.pixelY,self.pixelState)

pixel1 = Pixel(0,0,0,1000)
pixel2 = Pixel(4,4,0,500)

while True:
    pixel1.update()
    pixel2.update()

```

:::caution[游닋 Bit치cora] 
Escribe en tu bit치cora lo siguiente:

1. Describe detalladamente c칩mo funciona este ejemplo.
2. 쮺u치les son los estados en el programa? 
3. 쮺u치les son los eventos/inputs en el programa?
4. 쮺u치les son las acciones en el programa?
:::



### Actividad 02

#### Implementando un sem치foro con m치quina de estados

Implementemos juntos un sem치foro simple (rojo, amarillo, verde) utilizando una m치quina de estados en Micropython. Representaremos cada color del sem치foro con un LED del display del micro:bit. 

:::caution[游닋 Bit치cora]
1. Escribe el c칩digo que soluciona este problema en tu bit치cora.
2. Identifica los estados, eventos y acciones en tu c칩digo.
:::



## Seek: Investigaci칩n 游댍

### Actividad 03

#### Controlando la pantalla con una m치quina de estados y concurrencia

Implementaremos juntos el siguiente programa que busca gestionar la concurrencia entre la secuencia de im치genes y la respuesta a la pulsaci칩n de botones.

Lee la siguiente descripci칩n del problema y luego analiza la soluci칩n implementada. Para el an치lisis 
trata de observar estas preguntas:

- 쮺칩mo es posible estructurar una aplicaci칩n usando una m치quina de estados para poder atender varios eventos de manera concurrente?
- 쮺칩mo haces para probar que el programa est치 correcto? 

**Descripci칩n del problema**

Imagina un programa para el micro:bit que muestra diferentes expresiones en la pantalla seg칰n un ciclo de tiempo, pero que tambi칠n reacciona de inmediato si presionas un bot칩n. Al iniciar, se muestra una cara feliz durante un segundo y medio. Despu칠s, el micro:bit cambia a una expresi칩n sonriente que dura un segundo. Luego, aparece una cara triste durante dos segundos, y el ciclo vuelve a comenzar.

Sin embargo, si en cualquier momento se presiona el bot칩n A mientras la cara feliz o la sonriente est치n en pantalla, el micro:bit interrumpe el ciclo y muestra inmediatamente la cara triste o feliz, respectivamente. Si se presiona el bot칩n A mientras la cara triste est치 en pantalla, el dispositivo cambia a la expresi칩n sonriente. As칤, el programa combina una secuencia visual predefinida con la capacidad de responder r치pidamente a la interacci칩n del usuario.

**Modelando del programa con una m치quina de estados**

![State Machine Model](../../../assets/stateMachineExample.webp)

``` py
from microbit import *
import utime

STATE_INIT = 0
STATE_HAPPY = 1
STATE_SMILE = 2
STATE_SAD = 3

HAPPY_INTERVAL = 1500
SMILE_INTERVAL = 1000
SAD_INTERVAL = 2000

current_state = STATE_INIT
start_time = 0
interval = 0

while True:
    # pseudoestado STATE_INIT
    if current_state == STATE_INIT:
        display.show(Image.HAPPY)
        start_time = utime.ticks_ms()
        interval = HAPPY_INTERVAL
        current_state = STATE_HAPPY
    elif current_state == STATE_HAPPY:
        if button_a.was_pressed():
            # Acciones para el evento
            display.show(Image.SAD)
            # Acciones de entrada para el siguiente estado
            start_time = utime.ticks_ms()
            interval = SAD_INTERVAL
            current_state = STATE_SAD
        if utime.ticks_diff(utime.ticks_ms(), start_time) > interval:
            # Acciones para el evento
            display.show(Image.SMILE)
            # Acciones de entrada para el siguiente estado
            start_time = utime.ticks_ms()
            interval = SMILE_INTERVAL
            current_state = STATE_SMILE
    elif current_state == STATE_SMILE:
        if button_a.was_pressed():
            display.show(Image.HAPPY)
            start_time = utime.ticks_ms()
            interval = HAPPY_INTERVAL
            current_state = STATE_HAPPY
        if utime.ticks_diff(utime.ticks_ms(), start_time) > interval:
            display.show(Image.SAD)
            start_time = utime.ticks_ms()
            interval = SAD_INTERVAL
           current_state = STATE_SAD
    elif current_state == STATE_SAD:
        if button_a.was_pressed():
            display.show(Image.SMILE)
            start_time = utime.ticks_ms()
            interval = SMILE_INTERVAL
            current_state = STATE_SMILE
        if utime.ticks_diff(utime.ticks_ms(), start_time) > interval:
            display.show(Image.HAPPY)
            start_time = utime.ticks_ms()
            interval = HAPPY_INTERVAL
            current_state = STATE_HAPPY

```

:::caution[游닋 Bit치cora]
En tu bit치cora:

1. Explica por qu칠 decimos que este programa permite realizar de manera concurrente varias tareas.
2. Identifica los estados, eventos y acciones en el programa.
3. Describe y aplica al menos 3 vectores de prueba para el programa. Para definir un vector de prueba debes llevar al sistema a un estado, generar los eventos y observar el estado siguiente y las acciones que ocurrir치n. Por tanto, un vector de prueba tiene unas condiciones iniciales del sistema, unos resultados esperados y los resultados realmente obtenidos. Si el resultado obtenido es igual al esperado entonces el sistema pas칩 el vector de prueba, de lo contrario el sistema puede tener un error.
:::



## Apply: Aplicaci칩n 游

### Actividad 04

#### Dise침o de la l칩gica de una bomba temporizada

Dise침a la m치quina de estados para solucionar el siguiente problema:

En un escape room se requiere construir una aplicaci칩n para controlar una bomba temporizada. El circuito de control de la bomba est치 compuesto por cuatro sensores, denominados UP (bot칩n A), DOWN (bot칩n B), touch (bot칩n de touch) y ARMED (el gesto de shake de aceler칩metro). Tiene dos actuadores o dispositivos de salida que ser치n un display (la pantalla de LEDs) y un speaker.

**El controlador funciona as칤**:

Inicia en modo de configuraci칩n, es decir, sin hacer cuenta regresiva a칰n, la bomba est치 desarmada. El valor inicial del conteo regresivo es de 20 segundos.  

En el modo de configuraci칩n, los pulsadores UP y DOWN permiten aumentar o disminuir el tiempo inicial de la bomba.  

El tiempo se puede programar entre 10 y 60 segundos con cambios de 1 segundo. No olvides usar 
utime.ticks_ms() para medir el tiempo. Adem치s, 1 segundo equivale a 1000 milisegundos.  

Hacer shake (ARMED) arma la bomba, es decir, inicia el conteo regresivo.  

Una vez armada la bomba, comienza la cuenta regresiva que ser치 visualizada en la pantalla de LED

La bomba explotar치 (speaker) cuando el tiempo llegue a cero. 

Para volver a modo de configuraci칩n deber치s tocar el bot칩n touch.

:::caution[游닋 Bit치cora]
Construye un diagrama detallado de la m치quina de estados, incluyendo 
estados, eventos, transiciones y acciones.
:::


### Actividad 05

#### Implementando la Bomba Temporizada

Implementa el c칩digo para la bomba temporizada usando mycropython y el micro:bit, incluyendo la funcionalidad b치sica: configuraci칩n del tiempo, cuenta regresiva y detonaci칩n.

:::caution[游닋 Bit치cora]
Reporta en un tu bit치cora lo siguiente:
1. El c칩digo que implementa la bomba temporizada.
2. La definici칩n de los vectores de prueba b치sicos que permiten verificar el 
correcto funcionamiento del programa.
:::




## Reflect: Consolidaci칩n y metacognici칩n 游뱂

### Actividad 06

#### Autoevaluaci칩n

**Mirando hacia adentro: autoevaluaci칩n de m치quinas de estados y concurrencia**

El objetivo aqu칤 es doble. Primero, que recuperes de tu memoria los conceptos de dise침o y programaci칩n con m치quinas de estados sin ayuda externa. Este esfuerzo por recordar (pr치ctica de recuperaci칩n) es clave para un aprendizaje duradero. Segundo, que reflexiones sobre tu proceso de dise침o y depuraci칩n, una habilidad esencial para cualquier ingeniero.

:::caution[游닋 Bit치cora]

En tu bit치cora, sin consultar tu c칩digo, diagramas o notas, responde a las siguientes preguntas con tus propias palabras. Conc칠ntrate en el esfuerzo de recordar, no en la perfecci칩n de la respuesta.

**Parte 1: recuperaci칩n de conocimiento (Retrieval Practice)**

1.  Describe con tus palabras qu칠 es una m치quina de estados. 쮺u치les son sus cuatro componentes fundamentales que has utilizado en esta unidad?
2.  Explica por qu칠 la t칠cnica de m치quina de estados es tan 칰til para gestionar la "concurrencia" (atender un temporizador y botones "al mismo tiempo") en un dispositivo con un solo hilo de ejecuci칩n como el micro:bit. 쯈u칠 problema soluciona en comparaci칩n con usar funciones como `sleep()`?
3.  Imagina que tienes que a침adir una nueva funcionalidad a la bomba temporizada: si se agita (`shake`) el micro:bit *mientras* la cuenta regresiva est치 activa, el tiempo se reduce a la mitad. 쮺칩mo modificar칤as tu diagrama de m치quina de estados para incluir este nuevo evento y acci칩n?
4.  Explica qu칠 es un "vector de prueba" y por qu칠 es una herramienta crucial para verificar que una m치quina de estados funciona como se espera.

**Parte 2: reflexi칩n sobre tu proceso (Metacognici칩n)**

1.  쯈u칠 parte del dise침o de la bomba temporizada te result칩 m치s desafiante: crear el diagrama de estados (Actividad 04) o traducir ese diagrama a c칩digo MicroPython (Actividad 05)? 쯇or qu칠?
2.  Describe un error o "bug" que encontraste al implementar tu programa. 쮺칩mo te ayud칩 pensar en t칠rminos de estados, eventos y transiciones a identificar y solucionar el problema?
3.  El problema de la bomba era complejo. 쯈u칠 estrategia usaste para abordarlo? 쮺omenzaste con una versi칩n simple y a침adiste funcionalidades poco a poco?
4.  Ahora que entiendes el patr칩n de m치quina de estados, 쮼n qu칠 otro tipo de proyecto o sistema de entretenimiento digital crees que podr칤as aplicarlo?
:::


### Actividad 07

#### Coevaluaci칩n

**Aprendiendo juntos: coevaluaci칩n constructiva**

Dise침ar y programar es solo una parte del trabajo de un ingeniero; analizar y dar feedback sobre el trabajo de otros es igualmente importante. En esta actividad, revisar치s el dise침o y la implementaci칩n de la bomba temporizada de un compa침ero para ayudarle a mejorar y para ganar una nueva perspectiva.

:::caution[游닋 Bit치cora]

1.  Encuentra a un compa침ero de trabajo.
2.  Intercambien las URLs de sus bit치coras de aprendizaje.
3.  Revisa con atenci칩n las entradas de tu compa침ero para las Actividades 04 (diagrama de la bomba) y 05 (c칩digo y pruebas).
4.  Analiza de manera cr칤tica el dise침o y la implementaci칩n de tu compa침ero y deja un comentario de retroalimentaci칩n espec칤fico y constructivo.
5.  Conversa con tu compa침ero sobre su dise침o y c칩digo, y discutan sus comentarios.
:::


### Actividad 08

#### Feedback

**Mejorando la experiencia: tu feedback es clave**

Mi objetivo es crear la mejor experiencia de aprendizaje posible, y tu perspectiva es esencial para lograrlo. Este es tu espacio para darme feedback honesto y directo sobre esta unidad, lo que me ayudar치 a refinarla para futuros estudiantes.

:::caution[游닋 Bit치cora]

Responde a las siguientes preguntas con total sinceridad. 춰Cada comentario es valioso!

1.  **Continuar**: 쯈u칠 actividad, explicaci칩n o ejemplo de esta unidad te ayud칩 m치s a entender el poder de las m치quinas de estados? 쯈u칠 elemento consideras que es indispensable y deber칤a mantener?
2.  **Dejar de hacer**: 쮿ubo alg칰n paso o actividad que te pareci칩 confuso, innecesariamente complicado o que aport칩 poco a tu aprendizaje? 쯈u칠 cambiar칤as o eliminar칤as?
3.  **Empezar a hacer**: 쯈u칠 te habr칤a ayudado a entender mejor?
4.  **Ritmo y dificultad**: En una escala del 1 (muy f치cil) al 5 (muy dif칤cil), 쮺칩mo calificar칤as la dificultad de pasar del an치lisis de un programa (Actividad 03) al dise침o desde cero de uno complejo (Actividad 04 y 05)? 쯇or qu칠?
5.  **Comentario adicional**: 쮿ay algo m치s que te gustar칤a compartir sobre tu proceso de aprendizaje en esta unidad? 쮸lg칰n momento de frustraci칩n o de "춰Aha!" que quieras destacar?
:::

