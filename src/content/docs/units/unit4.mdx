---
title: Unidad 4
unitId: unit4
---

import { Aside } from '@astrojs/starlight/components';

<Aside type="danger">
NO USES IA PARA REALIZAR LAS ACTIVIDADES DE ESTA UNIDAD  

Esta unidad te propone un viaje cognitivo de descubrimiento. 
Descubrimos mediante la investigaci√≥n y la experimentaci√≥n. 
No se trata del resultado, sino del proceso. Es el proceso 
lo que transforma tu cerebro. Es la reflexi√≥n y la conexi√≥n 
de ideas lo que genera el aprendizaje.
</Aside>


## Introducci√≥n üìú

En esta unidad vas a aprender c√≥mo enviar l√≠neas de texto desde el micro:bit a 
un sketch en p5.js. Dichas l√≠neas de textos tendr√°n informaci√≥n de varios 
sensores del micro:bit, separada por comas, y terminadas por un salto de l√≠nea. 
Adicionalmente, vas a practicar de nuevo la t√©cnica de programaci√≥n de m√°quinas de estados.

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

Vas a enviar informaci√≥n desde el micro:bit a un sketch en p5.js. Para ello, 
usar√°s protocolos de comunicaci√≥n ASCII.

## Seek: Investigaci√≥n üîé

Vamos a analizar un caso de estudio que te servir√° de base 
para resolver el problema que te plantear√© en la fase de aplicaci√≥n.

### Actividad 1

Antes de comenzar con el caso de estudio te voy a pedir que explore este sitio:

- [Generative Design](http://www.generative-gestaltung.de/2/)

### Actividad 2

#### Caso de estudio: exploraci√≥n inicial

Vamos a explorar uno de los ejemplos de dise√±o generativo tomado del sitio 
[Generative Design](http://www.generative-gestaltung.de/2/).

En particular ser√° este [sketch](https://editor.p5js.org/juanferfranco/sketches/qZLVPNAHJ) 
que analizaremos juntos y luego [modificaremos](https://editor.p5js.org/juanferfranco/sketches/6ovAtsZ10) 
para controlarlo desde el micro:bit.

### Actividad 3

#### Caso de estudio: micro:bit

Una vez comprendido el funcionamiento del sketch, vamos a adaptarlo para que reciba informaci√≥n desde el micro:bit.
Primero te mostrar√© c√≥mo transmitir informaci√≥n desde el micro:bit.

Analicemos lentamente el siguiente c√≥digo:

``` py
# Imports go at the top
from microbit import *

uart.init(115200)
display.set_pixel(0,0,9)

while True:
    xValue = accelerometer.get_x()
    yValue = accelerometer.get_y()
    aState = button_a.is_pressed() 
    bState = button_b.is_pressed()
    data = "{},{},{},{}\n".format(xValue, yValue, aState,bState)
    uart.write(data)
    sleep(100) # Envia datos a 10 Hz
```

Probemos el programa del micro:bit con la aplicaci√≥n [SerialTerminal](https://juanferfranco.github.io/serialTerminal/) 
para ver los datos que se est√°n enviando.

Analizaremos varios asuntos:

- ¬øQu√© informaci√≥n se est√° enviando? ¬øC√≥mo se est√° enviando? 
Qu√© significa esta parte del c√≥digo:

``` py
"{},{},{},{}\n".format(xValue, yValue, aState,bState)
```

- Observa en la aplicaci√≥n SerialTerminal c√≥mo se ven los datos que se est√°n 
enviando. ¬øQu√© puedes inferir de la estructura de los datos?
- ¬øPor qu√© se separan los datos con comas y se termina con un salto de l√≠nea?
- ¬øQu√© crees que pasar√≠a si no se separan los datos con comas y no terminan con
un salto de l√≠nea?
- Para qu√© crees que se usa la funci√≥n `sleep(100)`? ¬øQu√© pasar√≠a si no se 
usara?
- Observa c√≥mo cambian los valores de `xValue` y `yValue` a medida que el micro:bit 
se inclina hacia la izquierda, derecha, adelante y atr√°s. ¬øQu√© valores toman 
`xValue` y `yValue` en cada caso?
- ¬øQu√© valores toman `aState` y `bState` cuando presionas los botones A y B?
- Observa qu√© ocurre si en vez de is_pressed() usas was_pressed(). ¬øQu√© diferencias
encuentras?

Finalmente, analiza este asunto: si el micro:bit tiene los siguientes datos xValue: 969, 
yValue: 652, aState: True, bState: False ¬øQu√© bytes se enviar√≠an por el puerto serial? Piensa, 
primero piensa por favor, y luego verifica con la aplicaci√≥n [SerialTerminal](https://juanferfranco.github.io/serialTerminal/). 
Ten presente que en `Mostrar datos como` puedes ver los bytes que se est√°n enviando mediante 
`Todo en HEX`.

### Actividad 4

#### Caso de estudio: p5.js 

Vamos a recorrer juntos la versi√≥n modificada. Para ello crearemos un nuevo proyecto p5.js.

- Modifica el archivo index.html as√≠:

``` html	
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.10/lib/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5.sound@0.2.0/dist/p5.sound.min.js"></script>
    <script src="https://unpkg.com/@gohai/p5.webserial@^1/libraries/p5.webserial.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <script src="sketch.js"></script>
  </body>
</html>

```

Necesitamos cargar, del ejemplo original, algunas im√°genes:

![p5.js files](../../../assets/unit4-files.png)

Ahora modifica el archivo sketch.js as√≠:

``` js
const lineModule = [];

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

function setup() {
  createCanvas(400, 400);
}

function draw() {
  background(220);
}
```

Ejecuta el sketch. Si no tienes errores podr√°s continuar. Reflexiona ¬øPara qu√© se 
usan estas im√°genes? ¬øQu√© representan? Revisa de nuevo el sketch original y 
analiza.

Recuerda que en el c√≥digo del micro:bit, cada 100 ms se est√°n enviando datos; 
sin embargo, la aplicaci√≥n no podr√° comenzar a usar dichos datos antes de que 
el usuario de manera expl√≠cita conecte el micro:bit a la aplicaci√≥n.

Entonces tienes un problema en el cual una aplicaci√≥n se comporta diferente dependiente 
del ESTADO en el que se encuentra. ¬øC√≥mo puedes solucionar este tipo de problema? 
Ya lo sabes: m√°quinas de estado.

Modifica el archivo sketch.js para que puedas controlar el estado de la aplicaci√≥n:

``` js
const lineModule = [];

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};

let appState = STATES.WAIT_MICROBIT_CONNECTION;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
}

function draw() {
  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      break;

    case STATES.RUNNING:
      break;
  }
}

```

Recuerda que en una aplicaci√≥n p5.js, la funci√≥n setup() se llama solo una vez. Luego 
se llamar√° la funci√≥n draw() cada 17 ms que equivale a 60 fps. No olvides entonces que 
cada vez que draw() se llama, la aplicaci√≥n eval√∫a el valor de appState para decidir 
qu√© har√° en ese frame, o dicho de otra manera qu√© har√° en el estado actual.

¬øRecuerdas que en las unidades anteriores ten√≠amos un pseudoestado llamado INIT? 
Se llama pseudoestado porque cuando la aplicaci√≥n est√° en este realmente NO EST√Å 
ESPERANDO nada. ¬øPuedes notar que no tenemos a INIT en este caso? Pero la verdad si est√°, 
solo que no como antes, la funci√≥n setup() est√° haciendo esa funci√≥n. ¬øLo ves?

Ahora es momento de programar el comportamiento del estado `STATES.WAIT_MICROBIT_CONNECTION`.  
Recuerda que la aplicaci√≥n en `este estado`, en cada frame, simplemente est√° esperando a que el 
usuario conecte el micro:bit. Observa el c√≥digo, agregar√© algunas variables:

``` js
const lineModule = [];

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

//*********************************
// C√≥digo para soportar el serial
let port;
let connectBtn;
let microBitConnected = false;
//*********************************

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
}

function draw() {
  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      break;

    case STATES.RUNNING:
      break;
  }
}

```

Observa que port, connectBtn y microBitConnected son variables globales. Se necesitan as√≠ 
porque las vas a manipular en cualquier funci√≥n del programa. No olvides que las variables 
que declaremos dentro de las funciones solo ser√°n visibles dentro de la funci√≥n, no por fuera.

Ahora a√±adiremos en la funci√≥n setup el c√≥digo que permitir√° conectarse al micro:bit:

``` js
const lineModule = [];

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

//*********************************
// C√≥digo para soportar el serial
let port;
let connectBtn;
let microBitConnected = false;
//*********************************

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
  //****************************************************
  // Adici√≥n del serial
  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
  //****************************************************
}

function draw() {
  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      break;

    case STATES.RUNNING:
      break;
  }
}
```

- createSerial(): crea el objeto que representar√° la conexi√≥n serial y devolver√° la direcci√≥n 
de memoria de este objeto que se almacenar√° en la variable port.
- createButton(): crea un objeto que representar√° a un bot√≥n en la aplicaci√≥n. La direcci√≥n de 
este objeto quedar√° almacenada en la variable connectBtn. 
- Observa que por medio de connectBtn, que contiene la direcci√≥n del objeto, se manipular√° la posici√≥n del objeto y el comportamiento de este al presionarlo con el mouse mousePressed. Nota que al m√©todo mousePressed() le est√°s 
pasando el nombre de una funci√≥n connectBtnClick. De esta manera al presionar el bot√≥n se llamar√° dicha funci√≥n.


A√±adimos entonces la funci√≥n connectBtnClick():

``` js
const lineModule = [];

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let connectionInitialized = false;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}


//****************************************************
function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
    connectionInitialized = false;
  } else {
    port.close();
  }
}
//****************************************************

function draw() {
  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      break;

    case STATES.RUNNING:
      break;
  }
}
```

¬øQu√© pasar√≠a ahora si das click al bot√≥n? Observa que en la funci√≥n se verifica si 
el puerto serial no est√° abierto. De ser as√≠ se abren con el m√©todo open("MicroPython", 115200). 
De lo contrario el puerto se cerrar√°. 

¬øPara qu√© abres el puerto serial? Se abre para poder recibir los datos del micro:bit, 
es decir, para conectarte al micro:bit y poder recibir los datos que est√° enviando en 
esta parte de su c√≥digo:

``` py
data = "{},{},{},{}\n".format(xValue, yValue, aState, bState)
uart.write(data)
```

Verifica el funcionamiento de la aplicaci√≥n hasta este momento. Todo deber√≠a estar 
bien.

Una vez ejecutes el programa nota que debe aparecer en la esquina superior izquierda 
el bot√≥n para conectarse al micro:bit: Connect to micro:bit. Observa la consola para 
que puedas ver los mensajes que te saldr√°n.

Observa detenidamente algo interesante. Una vez te conectas al micro:bit el bot√≥n sigue 
con el texto: `Connect to micro:bit`, pero ya est√°s conectado. Es necesario informar al 
usuario que la funcionalidad del bot√≥n cambiar√°.

Para lograr lo anterior, al inicio de draw() y por tanto en cada frame se comprobar√° si 
el puerto est√° abierto o cerrado. Esto permitir√° cambiar el texto del bot√≥n y adem√°s 
permitir√° generar el evento microBitConnected para informarle al resto de la aplicaci√≥n 
el estado del puerto.

``` js
const lineModule = [];

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let connectionInitialized = false;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);

  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
    connectionInitialized = false;
  } else {
    port.close();
  }
}

function draw() {
  //******************************************
  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
    microBitConnected = false;
  } else {
    microBitConnected = true;
    connectBtn.html("Disconnect");
  }
  //*******************************************

  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      break;

    case STATES.RUNNING:
      break;
  }
}
```

Ejecuta de nuevo la aplicaci√≥n y verifica que funciona correctamente.

Ahora vamos a a√±adir la parte del c√≥digo que lee los datos del micro:bit.

``` js
const lineModule = [];

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let connectionInitialized = false;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);

  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
    connectionInitialized = false;
  } else {
    port.close();
  }
}

function draw() {
  //******************************************
  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
    microBitConnected = false;
  } else {
    microBitConnected = true;
    connectBtn.html("Disconnect");

    if (port.opened() && !connectionInitialized) {
      port.clear();
      connectionInitialized = true;
    }

    if (port.availableBytes() > 0) {
      let data = port.readUntil("\n");
      if (data) {
        data = data.trim();
        let values = data.split(",");
        if (values.length == 4) {
          microBitX = int(values[0]) + windowWidth / 2;
          microBitY = int(values[1]) + windowHeight / 2;
          microBitAState = values[2].toLowerCase() === "true";
          microBitBState = values[3].toLowerCase() === "true";
          updateButtonStates(microBitAState, microBitBState);
        } else {
          print("No se est√°n recibiendo 4 datos del micro:bit");
        }
      }
    }
  }
  //*******************************************

  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      break;

    case STATES.RUNNING:
      break;
  }
}

```

Nota que solo se leen datos del micro:bit si el puerto est√° abierto ¬øPor qu√©? ¬øPodr√≠as 
leer datos si el puerto est√° cerrado? ¬øQu√© pasar√≠a si el puerto est√° cerrado y 
el micro:bit env√≠a datos?

Ahora te pedir√© que te concentres.  Para leer los datos que vienen del micro:bit, la 
aplicaci√≥n primero pregunta si al menos hay un dato disponible para leer. Piensa que 
hay una parte del c√≥digo de la biblioteca p5.webserial que se encarga de recibir 
los datos (como si fuera el portero de un edificio) y tu lo √∫nico que tienes que 
preguntar es si al menos ya tienes un dato para leer. 

``` js	
if (port.availableBytes() > 0) 
```
‚Äã
Una vez sabes que al menos hay un dato, te quedas esperando que est√© completa 
la `LINEA` que contiene todos los datos:

``` js	
let data = port.readUntil("\n");
```
‚Äã‚Äã
Pero ¬øC√≥mo sabes que ya est√° completa la l√≠nea? La funci√≥n readUntil esperar√° a que llegue 
el byte que representa el fin de l√≠nea: `"\n"`. Por tanto, el 
micro:bit tendr√° que MARCAR esto en cada paquete de datos que env√≠e:

``` py 
data = "{},{},{},{}\n".format(xValue, yValue, aState, bState)
```

¬øPuedes verlo? ¬øQu√© pasar√≠a si el micro:bit no env√≠a el `"\n"`? 

Una vez recibes el paquete completo que envi√≥ el micro:bit, verificas si el dato es v√°lido:

``` js	
if (data)
```
‚Äã
Y procedes a eliminar de los datos el `"\n"`, ya que este solo lo necesitas para 
marcar el fin del paquete de datos:

``` js
data = data.trim();
```
Ahora necesitas extraer de la cadena enviada cada uno de los datos, es decir, el valor 
de x, de y, el estado de A y de B:

``` js 
let values = data.split(",");
```
Regresa al c√≥digo del micro:bit:

``` py
data = "{},{},{},{}\n".format(xValue, yValue, aState, bState)
```
Cada `{}` es reemplazada por el valor de las variables xValue, yValue, aState, bState 
respectivamente. Adem√°s, observa el car√°cter `,` que separa cada valor.

En resumen hasta ahora. El micro:bit al enviar esta cadena:

``` py
data = "{},{},{},{}\n".format(xValue, yValue, aState, bState)
```

Est√° separando los valor por coma y marcando el fin del mensaje con un retorno de carro (`\n`) o enter. 

A esto se le conoce como un `PROTOCOLO`. Si la aplicaci√≥n en p5.js quiere recibir correctamente los 
datos tendr√° que seguir el `PROTOCOLO` para poder extraer correctamente la informaci√≥n.

Retomemos:

``` js
let values = data.split(",");
```

Esta parte devuelve un ARREGLO de cadenas y la direcci√≥n de este arreglo se almacenar√° en values. 

Considera ahora lo siguiente. Cuando est√°s comunicando dos aplicaciones es fundamental verificar la integridad de la 
informaci√≥n recibida. En este caso, el micro:bit est√° enviando 4 datos, por lo que la aplicaci√≥n
en p5.js debe verificar que efectivamente se recibieron los 4 datos:

``` js
if (values.length == 4) {
```
‚Äã
Para analizar lo que sigue debemos volver al c√≥digo del micro:bit:

``` py
data = "{},{},{},{}\n".format(xValue, yValue, aState, bState)
```

Como ya te dije antes, cada `{}` es reemplazada por el valor de las variables xValue, yValue,
aState, bState respectivamente. Ten presente que toda la informaci√≥n est√° 
[CODIFICAD en ASCII](https://www.asciitable.com/), 
es decir, si xValue es 100, realmente no est√°s enviando el byte que representa ese 100 sino 
que est√°s codificando cada n√∫mero en ASCII. Por tanto, el 100 realmente se env√≠a como tres 
bytes: 49, 48, 48.

Es por ello que esta parte del c√≥digo:

``` js
microBitX = int(values[0]) + windowWidth/2;
microBitY = int(values[1]) + windowHeight/2;
microBitAState = values[2].toLowerCase() === "true";
microBitBState = values[3].toLowerCase() === "true";
```
Necesita convertir cada cadena en un n√∫mero entero y adem√°s necesita convertir las cadenas
que representan los estados de los botones en un valor booleano.

Te estar√°s preguntando ¬øPor qu√© se suma `windowWidth/2` y `windowHeight/2` a los valores de x e y? 
Esta respuesta te toca analizarla a ti. No olvides escribir tus hallazgos en la bit√°cora.

Por √∫ltimo, la funci√≥n `updateButtonStates` se encargar√° de actualizar el estado de los botones. Vamos 
a a√±adir esta funci√≥n al c√≥digo:

``` js	
const lineModule = [];

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let connectionInitialized = false;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;
let microBitX = 0;
let microBitY = 0;
let microBitAState = false;
let microBitBState = false;
let prevmicroBitAState = false;
let prevmicroBitBState = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);

  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
    connectionInitialized = false;
  } else {
    port.close();
  }
}

function updateButtonStates(newAState, newBState) {
  // Generar eventos de keypressed
  if (newAState === true && prevmicroBitAState === false) {
    // create a new random color and line length
    lineModuleSize = random(50, 160);
    // remember click position
    clickPosX = microBitX;
    clickPosY = microBitY;
    print("A pressed");
  }
  // Generar eventos de key released
  if (newBState === false && prevmicroBitBState === true) {
    c = color(random(255), random(255), random(255), random(80, 100));
    print("B released");
  }

  prevmicroBitAState = newAState;
  prevmicroBitBState = newBState;
}

function draw() {
  //******************************************
  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
    microBitConnected = false;
  } else {
    microBitConnected = true;
    connectBtn.html("Disconnect");

    if (port.opened() && !connectionInitialized) {
      port.clear();
      connectionInitialized = true;
    }

    if (port.availableBytes() > 0) {
      let data = port.readUntil("\n");
      if (data) {
        data = data.trim();
        let values = data.split(",");
        if (values.length == 4) {
          microBitX = int(values[0]) + windowWidth / 2;
          microBitY = int(values[1]) + windowHeight / 2;
          microBitAState = values[2].toLowerCase() === "true";
          microBitBState = values[3].toLowerCase() === "true";
          updateButtonStates(microBitAState, microBitBState);
        } else {
          print("No se est√°n recibiendo 4 datos del micro:bit");
        }
      }
    }
  }
  //*******************************************

  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      break;

    case STATES.RUNNING:
      break;
  }
}
```

Ahora, si ejecutas la aplicaci√≥n y conectas el micro:bit, podr√°s ver que al presionar el bot√≥n A
se generar√° un evento de keypressed y al soltar el bot√≥n B se generar√° un evento de keyreleased. 
Adem√°s los valores de microBitX y microBitY se actualizar√°n con los valores que env√≠a el micro:bit.

¬øC√≥mo puedes verificar que los eventos de keypressed y keyreleased se est√°n generando? Piensa 
en c√≥mo puedes hacerlo y escribe tus hallazgos en la bit√°cora.

Ahora te pedir√© que analices el algoritmo updateButtonStates. ¬øQu√© hace? ¬øPor qu√© es necesario
almacenar el estado anterior de los botones? ¬øQu√© pasar√≠a si no se almacenara el estado anterior?

Seguimos. Vamos a a√±adir comportamientos a cada uno de los estados de la aplicaci√≥n. Recuerda, 
en un estado se espera la ocurrencia de uno o varios eventos. Eso puede generar acciones y 
posiblemente un cambio de estado.

``` js
    case STATES.WAIT_MICROBIT_CONNECTION:
      // No puede comenzar a dibujar hasta que no se conecte el microbit
      // evento 1:
      if (microBitConnected === true) {
        // Preparo todo para el estado en el pr√≥ximo frame
        print("Microbit ready to draw");
        strokeWeight(0.75);
        c = color(181, 157, 0);
        noCursor();
        appState = STATES.RUNNING;
      }

      break;
```

En cada frame se verifica si el micro:bit est√° conectado. Si es as√≠, se prepara todo para 
el estado RUNNING. Te muestro el c√≥digo completo incluyendo las variables de aplicaci√≥n nuevas 
que utilizar√° el estado RUNNING, as√≠ como el resto del c√≥digo del sketch original:

``` js
let c;
let lineModuleSize = 0;
let angle = 0;
let angleSpeed = 1;
const lineModule = [];
let lineModuleIndex = 0;
let clickPosX = 0;
let clickPosY = 0;

function preload() {
  lineModule[1] = loadImage("02.svg");
  lineModule[2] = loadImage("03.svg");
  lineModule[3] = loadImage("04.svg");
  lineModule[4] = loadImage("05.svg");
}

let port;
let connectBtn;
let connectionInitialized = false;
let microBitConnected = false;

const STATES = {
  WAIT_MICROBIT_CONNECTION: "WAITMICROBIT_CONNECTION",
  RUNNING: "RUNNING",
};
let appState = STATES.WAIT_MICROBIT_CONNECTION;
let microBitX = 0;
let microBitY = 0;
let microBitAState = false;
let microBitBState = false;
let prevmicroBitAState = false;
let prevmicroBitBState = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);

  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(connectBtnClick);
}

function connectBtnClick() {
  if (!port.opened()) {
    port.open("MicroPython", 115200);
    connectionInitialized = false;
  } else {
    port.close();
  }
}

function updateButtonStates(newAState, newBState) {
  // Generar eventos de keypressed
  if (newAState === true && prevmicroBitAState === false) {
    // create a new random color and line length
    lineModuleSize = random(50, 160);
    // remember click position
    clickPosX = microBitX;
    clickPosY = microBitY;
    print("A pressed");
  }
  // Generar eventos de key released
  if (newBState === false && prevmicroBitBState === true) {
    c = color(random(255), random(255), random(255), random(80, 100));
    print("B released");
  }

  prevmicroBitAState = newAState;
  prevmicroBitBState = newBState;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  //******************************************
  if (!port.opened()) {
    connectBtn.html("Connect to micro:bit");
    microBitConnected = false;
  } else {
    microBitConnected = true;
    connectBtn.html("Disconnect");

    if (port.opened() && !connectionInitialized) {
      port.clear();
      connectionInitialized = true;
    }

    if (port.availableBytes() > 0) {
      let data = port.readUntil("\n");
      if (data) {
        data = data.trim();
        let values = data.split(",");
        if (values.length == 4) {
          microBitX = int(values[0]) + windowWidth / 2;
          microBitY = int(values[1]) + windowHeight / 2;
          microBitAState = values[2].toLowerCase() === "true";
          microBitBState = values[3].toLowerCase() === "true";
          updateButtonStates(microBitAState, microBitBState);
        } else {
          print("No se est√°n recibiendo 4 datos del micro:bit");
        }
      }
    }
  }
  //*******************************************

  switch (appState) {
    case STATES.WAIT_MICROBIT_CONNECTION:
      // No puede comenzar a dibujar hasta que no se conecte el microbit
      // evento 1:
      if (microBitConnected === true) {
        // Preparo todo para el estado en el pr√≥ximo frame
        print("Microbit ready to draw");
        strokeWeight(0.75);
        c = color(181, 157, 0);
        noCursor();
        appState = STATES.RUNNING;
      }

      break;

    case STATES.RUNNING:
      // EVENTO: estado de conexi√≥n del microbit
      if (microBitConnected === false) {
        print("Waiting microbit connection");
        cursor();
        appState = STATES.WAIT_MICROBIT_CONNECTION;
      }

      //EVENTO: recepci√≥n de datos seriales del micro:bit

      if (microBitAState === true) {
        let x = microBitX;
        let y = microBitY;

        if (keyIsPressed && keyCode === SHIFT) {
          if (abs(clickPosX - x) > abs(clickPosY - y)) {
            y = clickPosY;
          } else {
            x = clickPosX;
          }
        }

        push();
        translate(x, y);
        rotate(radians(angle));
        if (lineModuleIndex != 0) {
          tint(c);
          image(
            lineModule[lineModuleIndex],
            0,
            0,
            lineModuleSize,
            lineModuleSize
          );
        } else {
          stroke(c);
          line(0, 0, lineModuleSize, lineModuleSize);
        }
        angle += angleSpeed;
        pop();
      }

      break;
  }
}

function keyPressed() {
  if (keyCode == UP_ARROW) lineModuleSize += 5;
  if (keyCode == DOWN_ARROW) lineModuleSize -= 5;
  if (keyCode == LEFT_ARROW) angleSpeed -= 0.5;
  if (keyCode == RIGHT_ARROW) angleSpeed += 0.5;
}

function keyReleased() {
  if (key == "s" || key == "S") {
    let ts =
      year() +
      nf(month(), 2) +
      nf(day(), 2) +
      "_" +
      nf(hour(), 2) +
      nf(minute(), 2) +
      nf(second(), 2);
    saveCanvas(ts, "png");
  }
  if (keyCode == DELETE || keyCode == BACKSPACE) background(255);

  // reverse direction and mirror angle
  if (key == "d" || key == "D") {
    angle += 180;
    angleSpeed *= -1;
  }

  // default colors from 1 to 4
  if (key == "1") c = color(181, 157, 0);
  if (key == "2") c = color(0, 130, 164);
  if (key == "3") c = color(87, 35, 129);
  if (key == "4") c = color(197, 0, 123);

  // load svg for line module
  if (key == "5") lineModuleIndex = 0;
  if (key == "6") lineModuleIndex = 1;
  if (key == "7") lineModuleIndex = 2;
  if (key == "8") lineModuleIndex = 3;
  if (key == "9") lineModuleIndex = 4;
}

```

Observa el c√≥digo original y el nuevo c√≥digo. ¬øQu√© diferencias encuentras?
¬øQu√© pas√≥ con algunos eventos del mouse? ¬øQu√© paso con la funci√≥n relacionada 
con la barra de espacio del teclado?

Ejecuta la aplicaci√≥n. Mira en la consola los mensajes que se generan. Nota 
en particular uno que dice: `No se est√°n recibiendo 4 datos del micro:bit` ¬øQu√© significa 
esto? Analiza si este mensaje ocurre en varios frames o solo en uno. ¬øPor qu√©? 
¬øQu√© puedes hacer para solucionar este problema? (Ten presente que esta pregunta 
es abierta y no tiene una √∫nica respuesta).

Finalmente, juega con la aplicaci√≥n y `DIBUJA`.

## Apply: Aplicaci√≥n üõ†

Ahora que conoces los conceptos y t√©cnicas fundamentales para lograr 
una comunicaci√≥n serial entre el micro:bit y un sketch en p5.js, vas a 
aplicarlos en un proyecto.

### Actividad 5

#### El momento de aplicar lo aprendido

Selecciona uno de los ejemplos que exploraste en la actividad 1 y realiza 
las modificaciones necesarias para que interact√∫e con el siguiente c√≥digo corriendo 
en el micro:bit:

``` py
# Imports go at the top
from microbit import *

uart.init(115200)
display.set_pixel(0,0,9)

while True:
    xValue = accelerometer.get_x()
    yValue = accelerometer.get_y()
    aState = button_a.is_pressed() 
    bState = button_b.is_pressed()
    data = "{},{},{},{}\n".format(xValue, yValue, aState,bState)
    uart.write(data)
    sleep(100) # Envia datos a 10 Hz
```

<details>
<summary>¬øQu√© puedo hacer para trabajar en mi casa si no tengo un micro:bit?</summary>

Si no tienes un micro:bit puedes "emular" los datos que produce el micro:bit 
utilizando un emulador y conectando tanto la aplicaci√≥n p5.js como el 
emulador a un pareja de puertos seriales virtuales.

La idea es esta:

![Virtual COM](../../../assets/virtualCom.webp)

Para lograr esto necesitas lo siguiente:

1. Instalar [este](https://com0com.sourceforge.net/) driver de 
virtual serial port.
2. Configurar los puertos con el programa Setup for com0com que 
viene con la instalaci√≥n.
3. Instalar [node.js](https://nodejs.org/en).
4. La aplicaci√≥n que emular√° al micro:bit. Te propongo 
[esta](https://github.com/juanferfranco/serialEmulator). Ten cuidado 
al momento de seleccionar el puerto serial virtual que usar√°s para 
emular al micro:bit. Debe ser uno de los puertos seriales virtuales 
configurados en el paso 2.
5. Necesitas realizar una modificaci√≥n a la manera como te conectas 
desde p5.js al micro:bit as√≠:

``` js 
function setup() {
  port = createSerial();
  connectBtn = createButton("Connect to micro:bit");
  connectBtn.position(0, 0);
  connectBtn.mousePressed(() => connectBtnClick('emu'));
}

function connectBtnClick(mode = 'emu') {
  if (!port.opened()) {
    if (mode === 'micro') {
      port.open('MicroPython', 115200);
    } else {
      port.open(115200);
    }
    connectionInitialized = false;
  } else {
    port.close();
  }
}
```
El c√≥digo anterior te permitir√° seleccionar alguno de los puertos 
seriales que tengas disponibles en tu sistema, incluyendo el 
virtual serial port y el que aparece cuando se conecta un micro:bit.

Ten en cuenta que debes seleccionar un puerto serial virtual diferente 
al seleccionado para el emulador, pero que est√© conectado a este. Eso 
lo configuras con la aplicaci√≥n Setup for com0com.

Este diagrama muestra c√≥mo se relacionar√≠an algunos de los 
programas anteriores:

![Diagrama completo](../../../assets/virtualComParts.webp)


</details>


## Evidencias üóÇÔ∏è

<Aside type="note" title="RUBRICA!">
- El plazo m√°ximo de entrega es 11 minutos antes de la segunda sesi√≥n 
presencial de la semana del 1 de septiembre de 2025. En ese momento 
cerrar√© la rama con la bit√°cora y haremos la evaluaci√≥n. En este espacio 
es fundamental tu asistencia para realizar la evaluaci√≥n de tu trabajo 
con el profesor.
- Cualquier omisi√≥n en la secci√≥n c√≥digo de la bit√°cora ser√° penalizada con 
1 unidad en la nota final.
- Si tu c√≥digo no reproduce la funcionalidad del video la nota ser√° 0.
- Si no se entrega el video solicitado la nota es 0, aunque se entregue 
el c√≥digo que lo reproduzca.
- Si el video no abre o no es visible la nota es 0.
- Si en tu video no se muestra claramente c√≥mo los sensores del micro:bit afectan 
la aplicaci√≥n p5.js y su efecto en ella la nota ser√° 0.
- Se asume que usar√°s el c√≥digo del micro:bit suministrado. De lo contrario 
tu nota ser√° 1 o 0.

| Escala de evaluaci√≥n | Nota 
| :--- | :--- 
| Tu proyecto funciona con 4 sensores | 5
| Tu proyecto funciona con 3 sensores | 4
| Tu proyecto funciona con 2 sensores | 3
| Tu proyecto funciona con 1 sensor | 2
| Tu proyecto no funciona con el c√≥digo del micro:bit suministrado | 1
| No entregas o el video no abre | 0

</Aside>

<Aside type="danger" title="EVIDENCIAS EN BIT√ÅCORA">
- Secci√≥n c√≥digo de la bit√°cora.
- Secci√≥n video de la bit√°cora que ser√° un enlace a un video no lista de youtube con las siguientes restricciones:
    - La calidad m√≠nima del video debe ser 1080p.
    - Video que muestre claramente la aplicaci√≥n p5.js modificada con cada uno de los valores xValue, yValue, aState,bState.
    - Debes editar el video y realizar una composici√≥n de modo que en un lado se vea la aplicaci√≥n p5.js 
    y en otro lado muestres la manipulaci√≥n del micro:bit.
    - Al comienzo debes mostrar el proceso completo desde la conexi√≥n del micro:bit hasta la interacci√≥n con la aplicaci√≥n.
    - Muestra con texto en el video el momento en el que los sensores del micro:bit est√°n siendo usados en la aplicaci√≥n 
    y su efecto en ella.
</Aside>

## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

Una vez termines esta unidad invierte en ti unos minutos para 
reflexionar sobre tu proceso de aprendizaje.

1. ¬øQu√© es un protocolo de comunicaci√≥n y por qu√© es importante en la comunicaci√≥n serial?  
2. ¬øPor qu√© se separan los datos con comas en el protocolo ASCII que exploramos?  
3. ¬øPor qu√© es necesario terminar los datos con un car√°cter que marque el fin del mensaje?  
4. ¬øPor qu√© fue necesario usar una m√°quina de estados en la aplicaci√≥n modificada de p5.js?  
5. ¬øC√≥mo se formatean los datos en el micro:bit para ser enviados por el puerto serial?  
6. ¬øQu√© significa que los datos enviados por el micro:bit est√°n codificados en ASCII?  
7. ¬øPor qu√© es necesario en la aplicaci√≥n de p5.js preguntar si hay bytes disponibles en el puerto serial antes de leerlos? 

``` js
if (port.availableBytes() > 0) {
    let data = port.readUntil("\n");
```

8. ¬øQu√© hiciste bien en esta unidad que debes continuar haciendo?
9. ¬øQu√© deber√≠as comenzar a hacer para mejorar tu proceso?
